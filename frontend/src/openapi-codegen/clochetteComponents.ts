/**
 * Generated by @openapi-codegen
 *
 * @version 2.1.1
 */
import * as reactQuery from '@tanstack/react-query';
import { useClochetteContext, ClochetteContext } from './clochetteContext';
import type * as Fetcher from './clochetteFetcher';
import { clochetteFetch } from './clochetteFetcher';
import type * as Schemas from './clochetteSchemas';

export type RootError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.HTTPError;
    }
  | {
      status: 401;
      payload: Schemas.HTTPError;
    }
  | {
      status: 404;
      payload: Schemas.HTTPError;
    }
>;

export type RootVariables = ClochetteContext['fetcherOptions'];

/**
 * Root endpoint.
 */
export const fetchRoot = (variables: RootVariables, signal?: AbortSignal) => clochetteFetch<Schemas.RootResponse, RootError, undefined, {}, {}, {}>({ url: '/api/v1/', method: 'get', ...variables, signal });

/**
 * Root endpoint.
 */
export const useRoot = <TData = Schemas.RootResponse>(variables: RootVariables, options?: Omit<reactQuery.UseQueryOptions<Schemas.RootResponse, RootError, TData>, 'queryKey' | 'queryFn'>) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useClochetteContext(options);
  return reactQuery.useQuery<Schemas.RootResponse, RootError, TData>({
    queryKey: queryKeyFn({ path: '/api/v1/', operationId: 'root', variables }),
    queryFn: ({ signal }) => fetchRoot({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions
  });
};

export type HealthError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.HTTPError;
    }
  | {
      status: 401;
      payload: Schemas.HTTPError;
    }
  | {
      status: 404;
      payload: Schemas.HTTPError;
    }
>;

export type HealthVariables = ClochetteContext['fetcherOptions'];

/**
 * Health endpoint.
 */
export const fetchHealth = (variables: HealthVariables, signal?: AbortSignal) => clochetteFetch<Schemas.HealthResponse, HealthError, undefined, {}, {}, {}>({ url: '/api/v1/health', method: 'get', ...variables, signal });

/**
 * Health endpoint.
 */
export const useHealth = <TData = Schemas.HealthResponse>(variables: HealthVariables, options?: Omit<reactQuery.UseQueryOptions<Schemas.HealthResponse, HealthError, TData>, 'queryKey' | 'queryFn'>) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useClochetteContext(options);
  return reactQuery.useQuery<Schemas.HealthResponse, HealthError, TData>({
    queryKey: queryKeyFn({ path: '/api/v1/health', operationId: 'health', variables }),
    queryFn: ({ signal }) => fetchHealth({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions
  });
};

export type ErrorError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.HTTPError;
    }
  | {
      status: 401;
      payload: Schemas.HTTPError;
    }
  | {
      status: 404;
      payload: Schemas.HTTPError;
    }
  | {
      status: 500;
      payload: void;
    }
>;

export type ErrorVariables = ClochetteContext['fetcherOptions'];

/**
 * Error endpoint, which need to be used to test the exception monitor middleware.
 */
export const fetchError = (variables: ErrorVariables, signal?: AbortSignal) => clochetteFetch<undefined, ErrorError, undefined, {}, {}, {}>({ url: '/api/v1/error', method: 'get', ...variables, signal });

/**
 * Error endpoint, which need to be used to test the exception monitor middleware.
 */
export const useError = <TData = undefined>(variables: ErrorVariables, options?: Omit<reactQuery.UseQueryOptions<undefined, ErrorError, TData>, 'queryKey' | 'queryFn'>) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useClochetteContext(options);
  return reactQuery.useQuery<undefined, ErrorError, TData>({
    queryKey: queryKeyFn({ path: '/api/v1/error', operationId: 'error', variables }),
    queryFn: ({ signal }) => fetchError({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions
  });
};

export type VersionError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.HTTPError;
    }
  | {
      status: 401;
      payload: Schemas.HTTPError;
    }
  | {
      status: 404;
      payload: Schemas.HTTPError;
    }
>;

export type VersionVariables = ClochetteContext['fetcherOptions'];

/**
 * Version endpoint.
 */
export const fetchVersion = (variables: VersionVariables, signal?: AbortSignal) => clochetteFetch<Schemas.VersionResponse, VersionError, undefined, {}, {}, {}>({ url: '/api/v1/version', method: 'get', ...variables, signal });

/**
 * Version endpoint.
 */
export const useVersion = <TData = Schemas.VersionResponse>(variables: VersionVariables, options?: Omit<reactQuery.UseQueryOptions<Schemas.VersionResponse, VersionError, TData>, 'queryKey' | 'queryFn'>) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useClochetteContext(options);
  return reactQuery.useQuery<Schemas.VersionResponse, VersionError, TData>({
    queryKey: queryKeyFn({ path: '/api/v1/version', operationId: 'version', variables }),
    queryFn: ({ signal }) => fetchVersion({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions
  });
};

export type ReadAccountsQueryParams = {
  username?: string | null;
  last_name?: string | null;
  first_name?: string | null;
  promotion_year?: number | null;
  scope?: Schemas.SecurityScopes | null;
  is_active?: boolean | null;
};

export type ReadAccountsError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.HTTPError;
    }
  | {
      status: 401;
      payload: Schemas.HTTPError;
    }
  | {
      status: 404;
      payload: Schemas.HTTPError;
    }
  | {
      status: 422;
      payload: Schemas.HTTPValidationError;
    }
>;

export type ReadAccountsResponse = Schemas.Account[];

export type ReadAccountsVariables = {
  queryParams?: ReadAccountsQueryParams;
} & ClochetteContext['fetcherOptions'];

/**
 * Retrieve a list of accounts.
 *
 * This endpoint requires authentication with the "president" scope.
 */
export const fetchReadAccounts = (variables: ReadAccountsVariables, signal?: AbortSignal) =>
  clochetteFetch<ReadAccountsResponse, ReadAccountsError, undefined, {}, ReadAccountsQueryParams, {}>({ url: '/api/v1/account/', method: 'get', ...variables, signal });

/**
 * Retrieve a list of accounts.
 *
 * This endpoint requires authentication with the "president" scope.
 */
export const useReadAccounts = <TData = ReadAccountsResponse>(variables: ReadAccountsVariables, options?: Omit<reactQuery.UseQueryOptions<ReadAccountsResponse, ReadAccountsError, TData>, 'queryKey' | 'queryFn'>) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useClochetteContext(options);
  return reactQuery.useQuery<ReadAccountsResponse, ReadAccountsError, TData>({
    queryKey: queryKeyFn({ path: '/api/v1/account/', operationId: 'readAccounts', variables }),
    queryFn: ({ signal }) => fetchReadAccounts({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions
  });
};

export type CreateAccountError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.HTTPError;
    }
  | {
      status: 401;
      payload: Schemas.HTTPError;
    }
  | {
      status: 404;
      payload: Schemas.HTTPError;
    }
  | {
      status: 422;
      payload: Schemas.HTTPValidationError;
    }
>;

export type CreateAccountVariables = {
  body: Schemas.AccountCreate;
} & ClochetteContext['fetcherOptions'];

/**
 * Create a new account.
 */
export const fetchCreateAccount = (variables: CreateAccountVariables, signal?: AbortSignal) => clochetteFetch<Schemas.Account, CreateAccountError, Schemas.AccountCreate, {}, {}, {}>({ url: '/api/v1/account/', method: 'post', ...variables, signal });

/**
 * Create a new account.
 */
export const useCreateAccount = (options?: Omit<reactQuery.UseMutationOptions<Schemas.Account, CreateAccountError, CreateAccountVariables>, 'mutationFn'>) => {
  const { fetcherOptions } = useClochetteContext();
  return reactQuery.useMutation<Schemas.Account, CreateAccountError, CreateAccountVariables>({
    mutationFn: (variables: CreateAccountVariables) => fetchCreateAccount({ ...fetcherOptions, ...variables }),
    ...options
  });
};

export type ReadAccountPathParams = {
  accountId: number;
};

export type ReadAccountError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.HTTPError;
    }
  | {
      status: 401;
      payload: Schemas.HTTPError;
    }
  | {
      status: 404;
      payload: Schemas.HTTPError;
    }
  | {
      status: 422;
      payload: Schemas.HTTPValidationError;
    }
>;

export type ReadAccountVariables = {
  pathParams: ReadAccountPathParams;
} & ClochetteContext['fetcherOptions'];

/**
 * Retrieve an account by ID.
 *
 * This endpoint requires authentication with the "president" scope.
 */
export const fetchReadAccount = (variables: ReadAccountVariables, signal?: AbortSignal) =>
  clochetteFetch<Schemas.Account, ReadAccountError, undefined, {}, {}, ReadAccountPathParams>({ url: '/api/v1/account/{accountId}', method: 'get', ...variables, signal });

/**
 * Retrieve an account by ID.
 *
 * This endpoint requires authentication with the "president" scope.
 */
export const useReadAccount = <TData = Schemas.Account>(variables: ReadAccountVariables, options?: Omit<reactQuery.UseQueryOptions<Schemas.Account, ReadAccountError, TData>, 'queryKey' | 'queryFn'>) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useClochetteContext(options);
  return reactQuery.useQuery<Schemas.Account, ReadAccountError, TData>({
    queryKey: queryKeyFn({ path: '/api/v1/account/{account_id}', operationId: 'readAccount', variables }),
    queryFn: ({ signal }) => fetchReadAccount({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions
  });
};

export type UpdateAccountPathParams = {
  accountId: number;
};

export type UpdateAccountError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.HTTPError;
    }
  | {
      status: 401;
      payload: Schemas.HTTPError;
    }
  | {
      status: 404;
      payload: Schemas.HTTPError;
    }
  | {
      status: 422;
      payload: Schemas.HTTPValidationError;
    }
>;

export type UpdateAccountVariables = {
  body?: Schemas.AccountUpdate;
  pathParams: UpdateAccountPathParams;
} & ClochetteContext['fetcherOptions'];

/**
 * Update an account by ID.
 *
 * This endpoint requires authentication with the "president" scope.
 */
export const fetchUpdateAccount = (variables: UpdateAccountVariables, signal?: AbortSignal) =>
  clochetteFetch<Schemas.Account, UpdateAccountError, Schemas.AccountUpdate, {}, {}, UpdateAccountPathParams>({ url: '/api/v1/account/{accountId}', method: 'put', ...variables, signal });

/**
 * Update an account by ID.
 *
 * This endpoint requires authentication with the "president" scope.
 */
export const useUpdateAccount = (options?: Omit<reactQuery.UseMutationOptions<Schemas.Account, UpdateAccountError, UpdateAccountVariables>, 'mutationFn'>) => {
  const { fetcherOptions } = useClochetteContext();
  return reactQuery.useMutation<Schemas.Account, UpdateAccountError, UpdateAccountVariables>({
    mutationFn: (variables: UpdateAccountVariables) => fetchUpdateAccount({ ...fetcherOptions, ...variables }),
    ...options
  });
};

export type DeleteAccountPathParams = {
  accountId: number;
};

export type DeleteAccountError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.HTTPError;
    }
  | {
      status: 401;
      payload: Schemas.HTTPError;
    }
  | {
      status: 404;
      payload: Schemas.HTTPError;
    }
  | {
      status: 422;
      payload: Schemas.HTTPValidationError;
    }
>;

export type DeleteAccountVariables = {
  pathParams: DeleteAccountPathParams;
} & ClochetteContext['fetcherOptions'];

/**
 * Delete an account by ID.
 *
 * This endpoint requires authentication with the "president" scope.
 */
export const fetchDeleteAccount = (variables: DeleteAccountVariables, signal?: AbortSignal) =>
  clochetteFetch<Schemas.Account, DeleteAccountError, undefined, {}, {}, DeleteAccountPathParams>({ url: '/api/v1/account/{accountId}', method: 'delete', ...variables, signal });

/**
 * Delete an account by ID.
 *
 * This endpoint requires authentication with the "president" scope.
 */
export const useDeleteAccount = (options?: Omit<reactQuery.UseMutationOptions<Schemas.Account, DeleteAccountError, DeleteAccountVariables>, 'mutationFn'>) => {
  const { fetcherOptions } = useClochetteContext();
  return reactQuery.useMutation<Schemas.Account, DeleteAccountError, DeleteAccountVariables>({
    mutationFn: (variables: DeleteAccountVariables) => fetchDeleteAccount({ ...fetcherOptions, ...variables }),
    ...options
  });
};

export type LoginError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.HTTPError;
    }
  | {
      status: 401;
      payload: Schemas.HTTPError;
    }
  | {
      status: 404;
      payload: Schemas.HTTPError;
    }
  | {
      status: 422;
      payload: Schemas.HTTPValidationError;
    }
>;

export type LoginVariables = {
  body: Schemas.BodyLogin;
} & ClochetteContext['fetcherOptions'];

/**
 * Logs in a user and returns an access token.
 */
export const fetchLogin = (variables: LoginVariables, signal?: AbortSignal) => clochetteFetch<Schemas.Token, LoginError, Schemas.BodyLogin, {}, {}, {}>({ url: '/api/v1/auth/login/', method: 'post', ...variables, signal });

/**
 * Logs in a user and returns an access token.
 */
export const useLogin = (options?: Omit<reactQuery.UseMutationOptions<Schemas.Token, LoginError, LoginVariables>, 'mutationFn'>) => {
  const { fetcherOptions } = useClochetteContext();
  return reactQuery.useMutation<Schemas.Token, LoginError, LoginVariables>({
    mutationFn: (variables: LoginVariables) => fetchLogin({ ...fetcherOptions, ...variables }),
    ...options
  });
};

export type ReadAccountMeError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.HTTPError;
    }
  | {
      status: 401;
      payload: Schemas.HTTPError;
    }
  | {
      status: 404;
      payload: Schemas.HTTPError;
    }
>;

export type ReadAccountMeVariables = ClochetteContext['fetcherOptions'];

/**
 * Returns the current user's account information.
 */
export const fetchReadAccountMe = (variables: ReadAccountMeVariables, signal?: AbortSignal) => clochetteFetch<Schemas.Account, ReadAccountMeError, undefined, {}, {}, {}>({ url: '/api/v1/auth/me/', method: 'get', ...variables, signal });

/**
 * Returns the current user's account information.
 */
export const useReadAccountMe = <TData = Schemas.Account>(variables: ReadAccountMeVariables, options?: Omit<reactQuery.UseQueryOptions<Schemas.Account, ReadAccountMeError, TData>, 'queryKey' | 'queryFn'>) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useClochetteContext(options);
  return reactQuery.useQuery<Schemas.Account, ReadAccountMeError, TData>({
    queryKey: queryKeyFn({ path: '/api/v1/auth/me/', operationId: 'readAccountMe', variables }),
    queryFn: ({ signal }) => fetchReadAccountMe({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions
  });
};

export type UpdateAccountMeError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.HTTPError;
    }
  | {
      status: 401;
      payload: Schemas.HTTPError;
    }
  | {
      status: 404;
      payload: Schemas.HTTPError;
    }
  | {
      status: 422;
      payload: Schemas.HTTPValidationError;
    }
>;

export type UpdateAccountMeVariables = {
  body?: Schemas.OwnAccountUpdate;
} & ClochetteContext['fetcherOptions'];

/**
 * Updates the current user's account information.
 */
export const fetchUpdateAccountMe = (variables: UpdateAccountMeVariables, signal?: AbortSignal) =>
  clochetteFetch<Schemas.Account, UpdateAccountMeError, Schemas.OwnAccountUpdate, {}, {}, {}>({ url: '/api/v1/auth/me/', method: 'put', ...variables, signal });

/**
 * Updates the current user's account information.
 */
export const useUpdateAccountMe = (options?: Omit<reactQuery.UseMutationOptions<Schemas.Account, UpdateAccountMeError, UpdateAccountMeVariables>, 'mutationFn'>) => {
  const { fetcherOptions } = useClochetteContext();
  return reactQuery.useMutation<Schemas.Account, UpdateAccountMeError, UpdateAccountMeVariables>({
    mutationFn: (variables: UpdateAccountMeVariables) => fetchUpdateAccountMe({ ...fetcherOptions, ...variables }),
    ...options
  });
};

export type V1ReadBarrelsQueryParams = {
  /**
   * @default false
   */
  all?: boolean;
  /**
   * @default false
   */
  mounted?: boolean;
};

export type V1ReadBarrelsError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.HTTPError;
    }
  | {
      status: 401;
      payload: Schemas.HTTPError;
    }
  | {
      status: 404;
      payload: Schemas.HTTPError;
    }
  | {
      status: 422;
      payload: Schemas.HTTPValidationError;
    }
>;

export type V1ReadBarrelsResponse = Schemas.BarrelV1[];

export type V1ReadBarrelsVariables = {
  queryParams?: V1ReadBarrelsQueryParams;
} & ClochetteContext['fetcherOptions'];

/**
 * Read barrels from the database.
 *
 * Query parameters:
 *     - `all`: If True, return all barrels. If False, return only mounted or unmounted barrels.
 *     - `mounted`: If True, return only mounted barrels. If False, return only unmounted barrels.
 */
export const fetchV1ReadBarrels = (variables: V1ReadBarrelsVariables, signal?: AbortSignal) =>
  clochetteFetch<V1ReadBarrelsResponse, V1ReadBarrelsError, undefined, {}, V1ReadBarrelsQueryParams, {}>({ url: '/api/v1/barrel/', method: 'get', ...variables, signal });

/**
 * Read barrels from the database.
 *
 * Query parameters:
 *     - `all`: If True, return all barrels. If False, return only mounted or unmounted barrels.
 *     - `mounted`: If True, return only mounted barrels. If False, return only unmounted barrels.
 */
export const useV1ReadBarrels = <TData = V1ReadBarrelsResponse>(variables: V1ReadBarrelsVariables, options?: Omit<reactQuery.UseQueryOptions<V1ReadBarrelsResponse, V1ReadBarrelsError, TData>, 'queryKey' | 'queryFn'>) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useClochetteContext(options);
  return reactQuery.useQuery<V1ReadBarrelsResponse, V1ReadBarrelsError, TData>({
    queryKey: queryKeyFn({ path: '/api/v1/barrel/', operationId: 'v1ReadBarrels', variables }),
    queryFn: ({ signal }) => fetchV1ReadBarrels({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions
  });
};

export type V1ReadDistinctBarrelsError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.HTTPError;
    }
  | {
      status: 401;
      payload: Schemas.HTTPError;
    }
  | {
      status: 404;
      payload: Schemas.HTTPError;
    }
>;

export type V1ReadDistinctBarrelsResponse = Schemas.BarrelV1[];

export type V1ReadDistinctBarrelsVariables = ClochetteContext['fetcherOptions'];

/**
 * Read distinct barrels from the database.
 */
export const fetchV1ReadDistinctBarrels = (variables: V1ReadDistinctBarrelsVariables, signal?: AbortSignal) =>
  clochetteFetch<V1ReadDistinctBarrelsResponse, V1ReadDistinctBarrelsError, undefined, {}, {}, {}>({ url: '/api/v1/barrel/distincts/', method: 'get', ...variables, signal });

/**
 * Read distinct barrels from the database.
 */
export const useV1ReadDistinctBarrels = <TData = V1ReadDistinctBarrelsResponse>(
  variables: V1ReadDistinctBarrelsVariables,
  options?: Omit<reactQuery.UseQueryOptions<V1ReadDistinctBarrelsResponse, V1ReadDistinctBarrelsError, TData>, 'queryKey' | 'queryFn'>
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useClochetteContext(options);
  return reactQuery.useQuery<V1ReadDistinctBarrelsResponse, V1ReadDistinctBarrelsError, TData>({
    queryKey: queryKeyFn({ path: '/api/v1/barrel/distincts/', operationId: 'v1ReadDistinctBarrels', variables }),
    queryFn: ({ signal }) => fetchV1ReadDistinctBarrels({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions
  });
};

export type V1UpdateBarrelPathParams = {
  barrelId: number;
};

export type V1UpdateBarrelError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.HTTPError;
    }
  | {
      status: 401;
      payload: Schemas.HTTPError;
    }
  | {
      status: 404;
      payload: Schemas.HTTPError;
    }
  | {
      status: 422;
      payload: Schemas.HTTPValidationError;
    }
>;

export type V1UpdateBarrelVariables = {
  body?: Schemas.BarrelUpdate;
  pathParams: V1UpdateBarrelPathParams;
} & ClochetteContext['fetcherOptions'];

/**
 * Update a barrel in the database.
 */
export const fetchV1UpdateBarrel = (variables: V1UpdateBarrelVariables, signal?: AbortSignal) =>
  clochetteFetch<Schemas.BarrelV1, V1UpdateBarrelError, Schemas.BarrelUpdate, {}, {}, V1UpdateBarrelPathParams>({ url: '/api/v1/barrel/{barrelId}', method: 'put', ...variables, signal });

/**
 * Update a barrel in the database.
 */
export const useV1UpdateBarrel = (options?: Omit<reactQuery.UseMutationOptions<Schemas.BarrelV1, V1UpdateBarrelError, V1UpdateBarrelVariables>, 'mutationFn'>) => {
  const { fetcherOptions } = useClochetteContext();
  return reactQuery.useMutation<Schemas.BarrelV1, V1UpdateBarrelError, V1UpdateBarrelVariables>({
    mutationFn: (variables: V1UpdateBarrelVariables) => fetchV1UpdateBarrel({ ...fetcherOptions, ...variables }),
    ...options
  });
};

export type V1ReadConsumablesQueryParams = {
  /**
   * @default false
   */
  all?: boolean;
};

export type V1ReadConsumablesError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.HTTPError;
    }
  | {
      status: 401;
      payload: Schemas.HTTPError;
    }
  | {
      status: 404;
      payload: Schemas.HTTPError;
    }
  | {
      status: 422;
      payload: Schemas.HTTPValidationError;
    }
>;

export type V1ReadConsumablesResponse = Schemas.ConsumableV1[];

export type V1ReadConsumablesVariables = {
  queryParams?: V1ReadConsumablesQueryParams;
} & ClochetteContext['fetcherOptions'];

/**
 * Retrieve a list of consumables.
 */
export const fetchV1ReadConsumables = (variables: V1ReadConsumablesVariables, signal?: AbortSignal) =>
  clochetteFetch<V1ReadConsumablesResponse, V1ReadConsumablesError, undefined, {}, V1ReadConsumablesQueryParams, {}>({ url: '/api/v1/consumable/', method: 'get', ...variables, signal });

/**
 * Retrieve a list of consumables.
 */
export const useV1ReadConsumables = <TData = V1ReadConsumablesResponse>(variables: V1ReadConsumablesVariables, options?: Omit<reactQuery.UseQueryOptions<V1ReadConsumablesResponse, V1ReadConsumablesError, TData>, 'queryKey' | 'queryFn'>) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useClochetteContext(options);
  return reactQuery.useQuery<V1ReadConsumablesResponse, V1ReadConsumablesError, TData>({
    queryKey: queryKeyFn({ path: '/api/v1/consumable/', operationId: 'v1ReadConsumables', variables }),
    queryFn: ({ signal }) => fetchV1ReadConsumables({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions
  });
};

export type V1ReadConsumablesDistinctsError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.HTTPError;
    }
  | {
      status: 401;
      payload: Schemas.HTTPError;
    }
  | {
      status: 404;
      payload: Schemas.HTTPError;
    }
>;

export type V1ReadConsumablesDistinctsResponse = Schemas.ConsumableV1[];

export type V1ReadConsumablesDistinctsVariables = ClochetteContext['fetcherOptions'];

/**
 * Retrieve a list of distinct consumables.
 */
export const fetchV1ReadConsumablesDistincts = (variables: V1ReadConsumablesDistinctsVariables, signal?: AbortSignal) =>
  clochetteFetch<V1ReadConsumablesDistinctsResponse, V1ReadConsumablesDistinctsError, undefined, {}, {}, {}>({ url: '/api/v1/consumable/distincts/', method: 'get', ...variables, signal });

/**
 * Retrieve a list of distinct consumables.
 */
export const useV1ReadConsumablesDistincts = <TData = V1ReadConsumablesDistinctsResponse>(
  variables: V1ReadConsumablesDistinctsVariables,
  options?: Omit<reactQuery.UseQueryOptions<V1ReadConsumablesDistinctsResponse, V1ReadConsumablesDistinctsError, TData>, 'queryKey' | 'queryFn'>
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useClochetteContext(options);
  return reactQuery.useQuery<V1ReadConsumablesDistinctsResponse, V1ReadConsumablesDistinctsError, TData>({
    queryKey: queryKeyFn({ path: '/api/v1/consumable/distincts/', operationId: 'v1ReadConsumablesDistincts', variables }),
    queryFn: ({ signal }) => fetchV1ReadConsumablesDistincts({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions
  });
};

export type V1UpdateConsumablePathParams = {
  consumableId: number;
};

export type V1UpdateConsumableError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.HTTPError;
    }
  | {
      status: 401;
      payload: Schemas.HTTPError;
    }
  | {
      status: 404;
      payload: Schemas.HTTPError;
    }
  | {
      status: 422;
      payload: Schemas.HTTPValidationError;
    }
>;

export type V1UpdateConsumableVariables = {
  body?: Schemas.ConsumableUpdate;
  pathParams: V1UpdateConsumablePathParams;
} & ClochetteContext['fetcherOptions'];

/**
 * Update a consumable.
 */
export const fetchV1UpdateConsumable = (variables: V1UpdateConsumableVariables, signal?: AbortSignal) =>
  clochetteFetch<Schemas.ConsumableV1, V1UpdateConsumableError, Schemas.ConsumableUpdate, {}, {}, V1UpdateConsumablePathParams>({ url: '/api/v1/consumable/{consumableId}', method: 'put', ...variables, signal });

/**
 * Update a consumable.
 */
export const useV1UpdateConsumable = (options?: Omit<reactQuery.UseMutationOptions<Schemas.ConsumableV1, V1UpdateConsumableError, V1UpdateConsumableVariables>, 'mutationFn'>) => {
  const { fetcherOptions } = useClochetteContext();
  return reactQuery.useMutation<Schemas.ConsumableV1, V1UpdateConsumableError, V1UpdateConsumableVariables>({
    mutationFn: (variables: V1UpdateConsumableVariables) => fetchV1UpdateConsumable({ ...fetcherOptions, ...variables }),
    ...options
  });
};

export type ReadConsumableItemsError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.HTTPError;
    }
  | {
      status: 401;
      payload: Schemas.HTTPError;
    }
  | {
      status: 404;
      payload: Schemas.HTTPError;
    }
>;

export type ReadConsumableItemsResponse = Schemas.ConsumableItem[];

export type ReadConsumableItemsVariables = ClochetteContext['fetcherOptions'];

/**
 * Retrieve a list of all consumable items.
 */
export const fetchReadConsumableItems = (variables: ReadConsumableItemsVariables, signal?: AbortSignal) =>
  clochetteFetch<ReadConsumableItemsResponse, ReadConsumableItemsError, undefined, {}, {}, {}>({ url: '/api/v1/consumable_item/', method: 'get', ...variables, signal });

/**
 * Retrieve a list of all consumable items.
 */
export const useReadConsumableItems = <TData = ReadConsumableItemsResponse>(variables: ReadConsumableItemsVariables, options?: Omit<reactQuery.UseQueryOptions<ReadConsumableItemsResponse, ReadConsumableItemsError, TData>, 'queryKey' | 'queryFn'>) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useClochetteContext(options);
  return reactQuery.useQuery<ReadConsumableItemsResponse, ReadConsumableItemsError, TData>({
    queryKey: queryKeyFn({ path: '/api/v1/consumable_item/', operationId: 'readConsumableItems', variables }),
    queryFn: ({ signal }) => fetchReadConsumableItems({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions
  });
};

export type CreateConsumableItemError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.HTTPError;
    }
  | {
      status: 401;
      payload: Schemas.HTTPError;
    }
  | {
      status: 404;
      payload: Schemas.HTTPError;
    }
  | {
      status: 422;
      payload: Schemas.HTTPValidationError;
    }
>;

export type CreateConsumableItemVariables = {
  body: Schemas.ConsumableItemCreate;
} & ClochetteContext['fetcherOptions'];

/**
 * Create a new consumable item.
 */
export const fetchCreateConsumableItem = (variables: CreateConsumableItemVariables, signal?: AbortSignal) =>
  clochetteFetch<Schemas.ConsumableItem, CreateConsumableItemError, Schemas.ConsumableItemCreate, {}, {}, {}>({ url: '/api/v1/consumable_item/', method: 'post', ...variables, signal });

/**
 * Create a new consumable item.
 */
export const useCreateConsumableItem = (options?: Omit<reactQuery.UseMutationOptions<Schemas.ConsumableItem, CreateConsumableItemError, CreateConsumableItemVariables>, 'mutationFn'>) => {
  const { fetcherOptions } = useClochetteContext();
  return reactQuery.useMutation<Schemas.ConsumableItem, CreateConsumableItemError, CreateConsumableItemVariables>({
    mutationFn: (variables: CreateConsumableItemVariables) => fetchCreateConsumableItem({ ...fetcherOptions, ...variables }),
    ...options
  });
};

export type ReadConsumableItemPathParams = {
  consumableItemId: number;
};

export type ReadConsumableItemError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.HTTPError;
    }
  | {
      status: 401;
      payload: Schemas.HTTPError;
    }
  | {
      status: 404;
      payload: Schemas.HTTPError;
    }
  | {
      status: 422;
      payload: Schemas.HTTPValidationError;
    }
>;

export type ReadConsumableItemVariables = {
  pathParams: ReadConsumableItemPathParams;
} & ClochetteContext['fetcherOptions'];

/**
 * Retrieve a specific consumable item by ID.
 */
export const fetchReadConsumableItem = (variables: ReadConsumableItemVariables, signal?: AbortSignal) =>
  clochetteFetch<Schemas.ConsumableItem, ReadConsumableItemError, undefined, {}, {}, ReadConsumableItemPathParams>({ url: '/api/v1/consumable_item/{consumableItemId}', method: 'get', ...variables, signal });

/**
 * Retrieve a specific consumable item by ID.
 */
export const useReadConsumableItem = <TData = Schemas.ConsumableItem>(variables: ReadConsumableItemVariables, options?: Omit<reactQuery.UseQueryOptions<Schemas.ConsumableItem, ReadConsumableItemError, TData>, 'queryKey' | 'queryFn'>) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useClochetteContext(options);
  return reactQuery.useQuery<Schemas.ConsumableItem, ReadConsumableItemError, TData>({
    queryKey: queryKeyFn({ path: '/api/v1/consumable_item/{consumable_item_id}', operationId: 'readConsumableItem', variables }),
    queryFn: ({ signal }) => fetchReadConsumableItem({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions
  });
};

export type UpdateConsumableItemPathParams = {
  consumableItemId: number;
};

export type UpdateConsumableItemError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.HTTPError;
    }
  | {
      status: 401;
      payload: Schemas.HTTPError;
    }
  | {
      status: 404;
      payload: Schemas.HTTPError;
    }
  | {
      status: 422;
      payload: Schemas.HTTPValidationError;
    }
>;

export type UpdateConsumableItemVariables = {
  body?: Schemas.ConsumableItemUpdate;
  pathParams: UpdateConsumableItemPathParams;
} & ClochetteContext['fetcherOptions'];

/**
 * Update a specific consumable item by ID.
 */
export const fetchUpdateConsumableItem = (variables: UpdateConsumableItemVariables, signal?: AbortSignal) =>
  clochetteFetch<Schemas.ConsumableItem, UpdateConsumableItemError, Schemas.ConsumableItemUpdate, {}, {}, UpdateConsumableItemPathParams>({ url: '/api/v1/consumable_item/{consumableItemId}', method: 'put', ...variables, signal });

/**
 * Update a specific consumable item by ID.
 */
export const useUpdateConsumableItem = (options?: Omit<reactQuery.UseMutationOptions<Schemas.ConsumableItem, UpdateConsumableItemError, UpdateConsumableItemVariables>, 'mutationFn'>) => {
  const { fetcherOptions } = useClochetteContext();
  return reactQuery.useMutation<Schemas.ConsumableItem, UpdateConsumableItemError, UpdateConsumableItemVariables>({
    mutationFn: (variables: UpdateConsumableItemVariables) => fetchUpdateConsumableItem({ ...fetcherOptions, ...variables }),
    ...options
  });
};

export type DeleteConsumableItemPathParams = {
  consumableItemId: number;
};

export type DeleteConsumableItemError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.HTTPError;
    }
  | {
      status: 401;
      payload: Schemas.HTTPError;
    }
  | {
      status: 404;
      payload: Schemas.HTTPError;
    }
  | {
      status: 422;
      payload: Schemas.HTTPValidationError;
    }
>;

export type DeleteConsumableItemVariables = {
  pathParams: DeleteConsumableItemPathParams;
} & ClochetteContext['fetcherOptions'];

/**
 * Delete a specific consumable item by ID.
 */
export const fetchDeleteConsumableItem = (variables: DeleteConsumableItemVariables, signal?: AbortSignal) =>
  clochetteFetch<Schemas.ConsumableItem, DeleteConsumableItemError, undefined, {}, {}, DeleteConsumableItemPathParams>({ url: '/api/v1/consumable_item/{consumableItemId}', method: 'delete', ...variables, signal });

/**
 * Delete a specific consumable item by ID.
 */
export const useDeleteConsumableItem = (options?: Omit<reactQuery.UseMutationOptions<Schemas.ConsumableItem, DeleteConsumableItemError, DeleteConsumableItemVariables>, 'mutationFn'>) => {
  const { fetcherOptions } = useClochetteContext();
  return reactQuery.useMutation<Schemas.ConsumableItem, DeleteConsumableItemError, DeleteConsumableItemVariables>({
    mutationFn: (variables: DeleteConsumableItemVariables) => fetchDeleteConsumableItem({ ...fetcherOptions, ...variables }),
    ...options
  });
};

export type ReadDrinkPathParams = {
  drinkId: number;
};

export type ReadDrinkError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.HTTPError;
    }
  | {
      status: 401;
      payload: Schemas.HTTPError;
    }
  | {
      status: 404;
      payload: Schemas.HTTPError;
    }
  | {
      status: 422;
      payload: Schemas.HTTPValidationError;
    }
>;

export type ReadDrinkVariables = {
  pathParams: ReadDrinkPathParams;
} & ClochetteContext['fetcherOptions'];

/**
 * Retrieve a drink by ID.
 */
export const fetchReadDrink = (variables: ReadDrinkVariables, signal?: AbortSignal) => clochetteFetch<Schemas.DrinkItem, ReadDrinkError, undefined, {}, {}, ReadDrinkPathParams>({ url: '/api/v1/drink/{drinkId}', method: 'get', ...variables, signal });

/**
 * Retrieve a drink by ID.
 */
export const useReadDrink = <TData = Schemas.DrinkItem>(variables: ReadDrinkVariables, options?: Omit<reactQuery.UseQueryOptions<Schemas.DrinkItem, ReadDrinkError, TData>, 'queryKey' | 'queryFn'>) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useClochetteContext(options);
  return reactQuery.useQuery<Schemas.DrinkItem, ReadDrinkError, TData>({
    queryKey: queryKeyFn({ path: '/api/v1/drink/{drink_id}', operationId: 'readDrink', variables }),
    queryFn: ({ signal }) => fetchReadDrink({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions
  });
};

export type UpdateDrinkPathParams = {
  drinkId: number;
};

export type UpdateDrinkError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.HTTPError;
    }
  | {
      status: 401;
      payload: Schemas.HTTPError;
    }
  | {
      status: 404;
      payload: Schemas.HTTPError;
    }
  | {
      status: 422;
      payload: Schemas.HTTPValidationError;
    }
>;

export type UpdateDrinkVariables = {
  body?: Schemas.DrinkItemUpdate;
  pathParams: UpdateDrinkPathParams;
} & ClochetteContext['fetcherOptions'];

/**
 * Update a drink by ID.
 */
export const fetchUpdateDrink = (variables: UpdateDrinkVariables, signal?: AbortSignal) =>
  clochetteFetch<Schemas.DrinkItem, UpdateDrinkError, Schemas.DrinkItemUpdate, {}, {}, UpdateDrinkPathParams>({ url: '/api/v1/drink/{drinkId}', method: 'put', ...variables, signal });

/**
 * Update a drink by ID.
 */
export const useUpdateDrink = (options?: Omit<reactQuery.UseMutationOptions<Schemas.DrinkItem, UpdateDrinkError, UpdateDrinkVariables>, 'mutationFn'>) => {
  const { fetcherOptions } = useClochetteContext();
  return reactQuery.useMutation<Schemas.DrinkItem, UpdateDrinkError, UpdateDrinkVariables>({
    mutationFn: (variables: UpdateDrinkVariables) => fetchUpdateDrink({ ...fetcherOptions, ...variables }),
    ...options
  });
};

export type DeleteDrinkPathParams = {
  drinkId: number;
};

export type DeleteDrinkError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.HTTPError;
    }
  | {
      status: 401;
      payload: Schemas.HTTPError;
    }
  | {
      status: 404;
      payload: Schemas.HTTPError;
    }
  | {
      status: 422;
      payload: Schemas.HTTPValidationError;
    }
>;

export type DeleteDrinkVariables = {
  pathParams: DeleteDrinkPathParams;
} & ClochetteContext['fetcherOptions'];

/**
 * Delete a drink by ID.
 */
export const fetchDeleteDrink = (variables: DeleteDrinkVariables, signal?: AbortSignal) =>
  clochetteFetch<Schemas.DrinkItem, DeleteDrinkError, undefined, {}, {}, DeleteDrinkPathParams>({ url: '/api/v1/drink/{drinkId}', method: 'delete', ...variables, signal });

/**
 * Delete a drink by ID.
 */
export const useDeleteDrink = (options?: Omit<reactQuery.UseMutationOptions<Schemas.DrinkItem, DeleteDrinkError, DeleteDrinkVariables>, 'mutationFn'>) => {
  const { fetcherOptions } = useClochetteContext();
  return reactQuery.useMutation<Schemas.DrinkItem, DeleteDrinkError, DeleteDrinkVariables>({
    mutationFn: (variables: DeleteDrinkVariables) => fetchDeleteDrink({ ...fetcherOptions, ...variables }),
    ...options
  });
};

export type ReadDrinksError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.HTTPError;
    }
  | {
      status: 401;
      payload: Schemas.HTTPError;
    }
  | {
      status: 404;
      payload: Schemas.HTTPError;
    }
>;

export type ReadDrinksResponse = Schemas.DrinkItem[];

export type ReadDrinksVariables = ClochetteContext['fetcherOptions'];

/**
 * Retrieve all drinks.
 */
export const fetchReadDrinks = (variables: ReadDrinksVariables, signal?: AbortSignal) => clochetteFetch<ReadDrinksResponse, ReadDrinksError, undefined, {}, {}, {}>({ url: '/api/v1/drink/', method: 'get', ...variables, signal });

/**
 * Retrieve all drinks.
 */
export const useReadDrinks = <TData = ReadDrinksResponse>(variables: ReadDrinksVariables, options?: Omit<reactQuery.UseQueryOptions<ReadDrinksResponse, ReadDrinksError, TData>, 'queryKey' | 'queryFn'>) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useClochetteContext(options);
  return reactQuery.useQuery<ReadDrinksResponse, ReadDrinksError, TData>({
    queryKey: queryKeyFn({ path: '/api/v1/drink/', operationId: 'readDrinks', variables }),
    queryFn: ({ signal }) => fetchReadDrinks({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions
  });
};

export type CreateDrinkError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.HTTPError;
    }
  | {
      status: 401;
      payload: Schemas.HTTPError;
    }
  | {
      status: 404;
      payload: Schemas.HTTPError;
    }
  | {
      status: 422;
      payload: Schemas.HTTPValidationError;
    }
>;

export type CreateDrinkVariables = {
  body: Schemas.DrinkItemCreate;
} & ClochetteContext['fetcherOptions'];

/**
 * Create a new drink.
 */
export const fetchCreateDrink = (variables: CreateDrinkVariables, signal?: AbortSignal) => clochetteFetch<Schemas.DrinkItem, CreateDrinkError, Schemas.DrinkItemCreate, {}, {}, {}>({ url: '/api/v1/drink/', method: 'post', ...variables, signal });

/**
 * Create a new drink.
 */
export const useCreateDrink = (options?: Omit<reactQuery.UseMutationOptions<Schemas.DrinkItem, CreateDrinkError, CreateDrinkVariables>, 'mutationFn'>) => {
  const { fetcherOptions } = useClochetteContext();
  return reactQuery.useMutation<Schemas.DrinkItem, CreateDrinkError, CreateDrinkVariables>({
    mutationFn: (variables: CreateDrinkVariables) => fetchCreateDrink({ ...fetcherOptions, ...variables }),
    ...options
  });
};

export type V1ReadGlassesQueryParams = {
  barrel_id?: number | null;
};

export type V1ReadGlassesError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.HTTPError;
    }
  | {
      status: 401;
      payload: Schemas.HTTPError;
    }
  | {
      status: 404;
      payload: Schemas.HTTPError;
    }
  | {
      status: 422;
      payload: Schemas.HTTPValidationError;
    }
>;

export type V1ReadGlassesResponse = Schemas.GlassV1[];

export type V1ReadGlassesVariables = {
  queryParams?: V1ReadGlassesQueryParams;
} & ClochetteContext['fetcherOptions'];

/**
 * Retrieve a list of glasses that match the given query parameters.
 */
export const fetchV1ReadGlasses = (variables: V1ReadGlassesVariables, signal?: AbortSignal) =>
  clochetteFetch<V1ReadGlassesResponse, V1ReadGlassesError, undefined, {}, V1ReadGlassesQueryParams, {}>({ url: '/api/v1/glass/', method: 'get', ...variables, signal });

/**
 * Retrieve a list of glasses that match the given query parameters.
 */
export const useV1ReadGlasses = <TData = V1ReadGlassesResponse>(variables: V1ReadGlassesVariables, options?: Omit<reactQuery.UseQueryOptions<V1ReadGlassesResponse, V1ReadGlassesError, TData>, 'queryKey' | 'queryFn'>) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useClochetteContext(options);
  return reactQuery.useQuery<V1ReadGlassesResponse, V1ReadGlassesError, TData>({
    queryKey: queryKeyFn({ path: '/api/v1/glass/', operationId: 'v1ReadGlasses', variables }),
    queryFn: ({ signal }) => fetchV1ReadGlasses({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions
  });
};

export type ReadOutOfStocksError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.HTTPError;
    }
  | {
      status: 401;
      payload: Schemas.HTTPError;
    }
  | {
      status: 404;
      payload: Schemas.HTTPError;
    }
>;

export type ReadOutOfStocksResponse = Schemas.OutOfStock[];

export type ReadOutOfStocksVariables = ClochetteContext['fetcherOptions'];

/**
 * Retrieve a list of out of stock items.
 */
export const fetchReadOutOfStocks = (variables: ReadOutOfStocksVariables, signal?: AbortSignal) => clochetteFetch<ReadOutOfStocksResponse, ReadOutOfStocksError, undefined, {}, {}, {}>({ url: '/api/v1/out_of_stock/', method: 'get', ...variables, signal });

/**
 * Retrieve a list of out of stock items.
 */
export const useReadOutOfStocks = <TData = ReadOutOfStocksResponse>(variables: ReadOutOfStocksVariables, options?: Omit<reactQuery.UseQueryOptions<ReadOutOfStocksResponse, ReadOutOfStocksError, TData>, 'queryKey' | 'queryFn'>) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useClochetteContext(options);
  return reactQuery.useQuery<ReadOutOfStocksResponse, ReadOutOfStocksError, TData>({
    queryKey: queryKeyFn({ path: '/api/v1/out_of_stock/', operationId: 'readOutOfStocks', variables }),
    queryFn: ({ signal }) => fetchReadOutOfStocks({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions
  });
};

export type ReadOutOfStockItemsBuyQueryParams = {
  name?: string | null;
  icon?: Schemas.IconName | null;
  sell_price?: number | null;
};

export type ReadOutOfStockItemsBuyError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.HTTPError;
    }
  | {
      status: 401;
      payload: Schemas.HTTPError;
    }
  | {
      status: 404;
      payload: Schemas.HTTPError;
    }
  | {
      status: 422;
      payload: Schemas.HTTPValidationError;
    }
>;

export type ReadOutOfStockItemsBuyResponse = Schemas.OutOfStockItem[];

export type ReadOutOfStockItemsBuyVariables = {
  queryParams?: ReadOutOfStockItemsBuyQueryParams;
} & ClochetteContext['fetcherOptions'];

/**
 * Retrieve a list of out of stock items for buying.
 */
export const fetchReadOutOfStockItemsBuy = (variables: ReadOutOfStockItemsBuyVariables, signal?: AbortSignal) =>
  clochetteFetch<ReadOutOfStockItemsBuyResponse, ReadOutOfStockItemsBuyError, undefined, {}, ReadOutOfStockItemsBuyQueryParams, {}>({ url: '/api/v1/out_of_stock_item/buy/', method: 'get', ...variables, signal });

/**
 * Retrieve a list of out of stock items for buying.
 */
export const useReadOutOfStockItemsBuy = <TData = ReadOutOfStockItemsBuyResponse>(
  variables: ReadOutOfStockItemsBuyVariables,
  options?: Omit<reactQuery.UseQueryOptions<ReadOutOfStockItemsBuyResponse, ReadOutOfStockItemsBuyError, TData>, 'queryKey' | 'queryFn'>
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useClochetteContext(options);
  return reactQuery.useQuery<ReadOutOfStockItemsBuyResponse, ReadOutOfStockItemsBuyError, TData>({
    queryKey: queryKeyFn({ path: '/api/v1/out_of_stock_item/buy/', operationId: 'readOutOfStockItemsBuy', variables }),
    queryFn: ({ signal }) => fetchReadOutOfStockItemsBuy({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions
  });
};

export type ReadOutOfStockItemsSellQueryParams = {
  name?: string | null;
  icon?: Schemas.IconName | null;
  sell_price?: number | null;
};

export type ReadOutOfStockItemsSellError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.HTTPError;
    }
  | {
      status: 401;
      payload: Schemas.HTTPError;
    }
  | {
      status: 404;
      payload: Schemas.HTTPError;
    }
  | {
      status: 422;
      payload: Schemas.HTTPValidationError;
    }
>;

export type ReadOutOfStockItemsSellResponse = Schemas.OutOfStockItem[];

export type ReadOutOfStockItemsSellVariables = {
  queryParams?: ReadOutOfStockItemsSellQueryParams;
} & ClochetteContext['fetcherOptions'];

/**
 * Retrieve a list of out of stock items for selling.
 */
export const fetchReadOutOfStockItemsSell = (variables: ReadOutOfStockItemsSellVariables, signal?: AbortSignal) =>
  clochetteFetch<ReadOutOfStockItemsSellResponse, ReadOutOfStockItemsSellError, undefined, {}, ReadOutOfStockItemsSellQueryParams, {}>({ url: '/api/v1/out_of_stock_item/sell/', method: 'get', ...variables, signal });

/**
 * Retrieve a list of out of stock items for selling.
 */
export const useReadOutOfStockItemsSell = <TData = ReadOutOfStockItemsSellResponse>(
  variables: ReadOutOfStockItemsSellVariables,
  options?: Omit<reactQuery.UseQueryOptions<ReadOutOfStockItemsSellResponse, ReadOutOfStockItemsSellError, TData>, 'queryKey' | 'queryFn'>
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useClochetteContext(options);
  return reactQuery.useQuery<ReadOutOfStockItemsSellResponse, ReadOutOfStockItemsSellError, TData>({
    queryKey: queryKeyFn({ path: '/api/v1/out_of_stock_item/sell/', operationId: 'readOutOfStockItemsSell', variables }),
    queryFn: ({ signal }) => fetchReadOutOfStockItemsSell({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions
  });
};

export type ReadOutOfStockItemPathParams = {
  outOfStockItemId: number;
};

export type ReadOutOfStockItemError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.HTTPError;
    }
  | {
      status: 401;
      payload: Schemas.HTTPError;
    }
  | {
      status: 404;
      payload: Schemas.HTTPError;
    }
  | {
      status: 422;
      payload: Schemas.HTTPValidationError;
    }
>;

export type ReadOutOfStockItemVariables = {
  pathParams: ReadOutOfStockItemPathParams;
} & ClochetteContext['fetcherOptions'];

/**
 * Retrieve an out of stock item by ID.
 */
export const fetchReadOutOfStockItem = (variables: ReadOutOfStockItemVariables, signal?: AbortSignal) =>
  clochetteFetch<Schemas.OutOfStockItem, ReadOutOfStockItemError, undefined, {}, {}, ReadOutOfStockItemPathParams>({ url: '/api/v1/out_of_stock_item/{outOfStockItemId}', method: 'get', ...variables, signal });

/**
 * Retrieve an out of stock item by ID.
 */
export const useReadOutOfStockItem = <TData = Schemas.OutOfStockItem>(variables: ReadOutOfStockItemVariables, options?: Omit<reactQuery.UseQueryOptions<Schemas.OutOfStockItem, ReadOutOfStockItemError, TData>, 'queryKey' | 'queryFn'>) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useClochetteContext(options);
  return reactQuery.useQuery<Schemas.OutOfStockItem, ReadOutOfStockItemError, TData>({
    queryKey: queryKeyFn({ path: '/api/v1/out_of_stock_item/{out_of_stock_item_id}', operationId: 'readOutOfStockItem', variables }),
    queryFn: ({ signal }) => fetchReadOutOfStockItem({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions
  });
};

export type UpdateOutOfStockItemPathParams = {
  outOfStockItemId: number;
};

export type UpdateOutOfStockItemError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.HTTPError;
    }
  | {
      status: 401;
      payload: Schemas.HTTPError;
    }
  | {
      status: 404;
      payload: Schemas.HTTPError;
    }
  | {
      status: 422;
      payload: Schemas.HTTPValidationError;
    }
>;

export type UpdateOutOfStockItemVariables = {
  body?: Schemas.OutOfStockItemUpdate;
  pathParams: UpdateOutOfStockItemPathParams;
} & ClochetteContext['fetcherOptions'];

/**
 * Update an existing out of stock item.
 */
export const fetchUpdateOutOfStockItem = (variables: UpdateOutOfStockItemVariables, signal?: AbortSignal) =>
  clochetteFetch<Schemas.OutOfStockItem, UpdateOutOfStockItemError, Schemas.OutOfStockItemUpdate, {}, {}, UpdateOutOfStockItemPathParams>({ url: '/api/v1/out_of_stock_item/{outOfStockItemId}', method: 'put', ...variables, signal });

/**
 * Update an existing out of stock item.
 */
export const useUpdateOutOfStockItem = (options?: Omit<reactQuery.UseMutationOptions<Schemas.OutOfStockItem, UpdateOutOfStockItemError, UpdateOutOfStockItemVariables>, 'mutationFn'>) => {
  const { fetcherOptions } = useClochetteContext();
  return reactQuery.useMutation<Schemas.OutOfStockItem, UpdateOutOfStockItemError, UpdateOutOfStockItemVariables>({
    mutationFn: (variables: UpdateOutOfStockItemVariables) => fetchUpdateOutOfStockItem({ ...fetcherOptions, ...variables }),
    ...options
  });
};

export type DeleteOutOfStockItemPathParams = {
  outOfStockItemId: number;
};

export type DeleteOutOfStockItemError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.HTTPError;
    }
  | {
      status: 401;
      payload: Schemas.HTTPError;
    }
  | {
      status: 404;
      payload: Schemas.HTTPError;
    }
  | {
      status: 422;
      payload: Schemas.HTTPValidationError;
    }
>;

export type DeleteOutOfStockItemVariables = {
  pathParams: DeleteOutOfStockItemPathParams;
} & ClochetteContext['fetcherOptions'];

/**
 * Delete an existing out of stock item.
 */
export const fetchDeleteOutOfStockItem = (variables: DeleteOutOfStockItemVariables, signal?: AbortSignal) =>
  clochetteFetch<Schemas.OutOfStockItem, DeleteOutOfStockItemError, undefined, {}, {}, DeleteOutOfStockItemPathParams>({ url: '/api/v1/out_of_stock_item/{outOfStockItemId}', method: 'delete', ...variables, signal });

/**
 * Delete an existing out of stock item.
 */
export const useDeleteOutOfStockItem = (options?: Omit<reactQuery.UseMutationOptions<Schemas.OutOfStockItem, DeleteOutOfStockItemError, DeleteOutOfStockItemVariables>, 'mutationFn'>) => {
  const { fetcherOptions } = useClochetteContext();
  return reactQuery.useMutation<Schemas.OutOfStockItem, DeleteOutOfStockItemError, DeleteOutOfStockItemVariables>({
    mutationFn: (variables: DeleteOutOfStockItemVariables) => fetchDeleteOutOfStockItem({ ...fetcherOptions, ...variables }),
    ...options
  });
};

export type CreateOutOfStockItemError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.HTTPError;
    }
  | {
      status: 401;
      payload: Schemas.HTTPError;
    }
  | {
      status: 404;
      payload: Schemas.HTTPError;
    }
  | {
      status: 422;
      payload: Schemas.HTTPValidationError;
    }
>;

export type CreateOutOfStockItemVariables = {
  body: Schemas.OutOfStockItemCreate;
} & ClochetteContext['fetcherOptions'];

/**
 * Create a new out of stock item.
 */
export const fetchCreateOutOfStockItem = (variables: CreateOutOfStockItemVariables, signal?: AbortSignal) =>
  clochetteFetch<Schemas.OutOfStockItem, CreateOutOfStockItemError, Schemas.OutOfStockItemCreate, {}, {}, {}>({ url: '/api/v1/out_of_stock_item/', method: 'post', ...variables, signal });

/**
 * Create a new out of stock item.
 */
export const useCreateOutOfStockItem = (options?: Omit<reactQuery.UseMutationOptions<Schemas.OutOfStockItem, CreateOutOfStockItemError, CreateOutOfStockItemVariables>, 'mutationFn'>) => {
  const { fetcherOptions } = useClochetteContext();
  return reactQuery.useMutation<Schemas.OutOfStockItem, CreateOutOfStockItemError, CreateOutOfStockItemVariables>({
    mutationFn: (variables: CreateOutOfStockItemVariables) => fetchCreateOutOfStockItem({ ...fetcherOptions, ...variables }),
    ...options
  });
};

export type V1ReadTransactionsQueryParams = {
  datetime__gt?: string | null;
  datetime__lt?: string | null;
  datetime?: string | null;
  payment_method?: Schemas.PaymentMethod | null;
  sale?: boolean | null;
  amount__gt?: number | null;
  amount__lt?: number | null;
  amount?: number | null;
  type?: Schemas.TransactionTypeV1 | null;
  description?: string | null;
};

export type V1ReadTransactionsError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.HTTPError;
    }
  | {
      status: 401;
      payload: Schemas.HTTPError;
    }
  | {
      status: 404;
      payload: Schemas.HTTPError;
    }
  | {
      status: 422;
      payload: Schemas.HTTPValidationError;
    }
>;

export type V1ReadTransactionsResponse = Schemas.TransactionV1[];

export type V1ReadTransactionsVariables = {
  queryParams?: V1ReadTransactionsQueryParams;
} & ClochetteContext['fetcherOptions'];

export const fetchV1ReadTransactions = (variables: V1ReadTransactionsVariables, signal?: AbortSignal) =>
  clochetteFetch<V1ReadTransactionsResponse, V1ReadTransactionsError, undefined, {}, V1ReadTransactionsQueryParams, {}>({ url: '/api/v1/transaction/', method: 'get', ...variables, signal });

export const useV1ReadTransactions = <TData = V1ReadTransactionsResponse>(variables: V1ReadTransactionsVariables, options?: Omit<reactQuery.UseQueryOptions<V1ReadTransactionsResponse, V1ReadTransactionsError, TData>, 'queryKey' | 'queryFn'>) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useClochetteContext(options);
  return reactQuery.useQuery<V1ReadTransactionsResponse, V1ReadTransactionsError, TData>({
    queryKey: queryKeyFn({ path: '/api/v1/transaction/', operationId: 'v1ReadTransactions', variables }),
    queryFn: ({ signal }) => fetchV1ReadTransactions({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions
  });
};

export type V1CreateTransactionError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.HTTPError;
    }
  | {
      status: 401;
      payload: Schemas.HTTPError;
    }
  | {
      status: 404;
      payload: Schemas.HTTPError;
    }
  | {
      status: 422;
      payload: Schemas.HTTPValidationError;
    }
>;

export type V1CreateTransactionVariables = {
  body: Schemas.TransactionFrontCreate;
} & ClochetteContext['fetcherOptions'];

export const fetchV1CreateTransaction = (variables: V1CreateTransactionVariables, signal?: AbortSignal) =>
  clochetteFetch<Schemas.TransactionV1, V1CreateTransactionError, Schemas.TransactionFrontCreate, {}, {}, {}>({ url: '/api/v1/transaction/', method: 'post', ...variables, signal });

export const useV1CreateTransaction = (options?: Omit<reactQuery.UseMutationOptions<Schemas.TransactionV1, V1CreateTransactionError, V1CreateTransactionVariables>, 'mutationFn'>) => {
  const { fetcherOptions } = useClochetteContext();
  return reactQuery.useMutation<Schemas.TransactionV1, V1CreateTransactionError, V1CreateTransactionVariables>({
    mutationFn: (variables: V1CreateTransactionVariables) => fetchV1CreateTransaction({ ...fetcherOptions, ...variables }),
    ...options
  });
};

export type V1ReadTransactionPathParams = {
  transactionId: number;
};

export type V1ReadTransactionError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.HTTPError;
    }
  | {
      status: 401;
      payload: Schemas.HTTPError;
    }
  | {
      status: 404;
      payload: Schemas.HTTPError;
    }
  | {
      status: 422;
      payload: Schemas.HTTPValidationError;
    }
>;

export type V1ReadTransactionVariables = {
  pathParams: V1ReadTransactionPathParams;
} & ClochetteContext['fetcherOptions'];

export const fetchV1ReadTransaction = (variables: V1ReadTransactionVariables, signal?: AbortSignal) =>
  clochetteFetch<Schemas.TransactionSingle, V1ReadTransactionError, undefined, {}, {}, V1ReadTransactionPathParams>({ url: '/api/v1/transaction/{transactionId}', method: 'get', ...variables, signal });

export const useV1ReadTransaction = <TData = Schemas.TransactionSingle>(variables: V1ReadTransactionVariables, options?: Omit<reactQuery.UseQueryOptions<Schemas.TransactionSingle, V1ReadTransactionError, TData>, 'queryKey' | 'queryFn'>) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useClochetteContext(options);
  return reactQuery.useQuery<Schemas.TransactionSingle, V1ReadTransactionError, TData>({
    queryKey: queryKeyFn({ path: '/api/v1/transaction/{transaction_id}', operationId: 'v1ReadTransaction', variables }),
    queryFn: ({ signal }) => fetchV1ReadTransaction({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions
  });
};

export type ReadTreasuriesError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.HTTPError;
    }
  | {
      status: 401;
      payload: Schemas.HTTPError;
    }
  | {
      status: 404;
      payload: Schemas.HTTPError;
    }
>;

export type ReadTreasuriesResponse = Schemas.Treasury[];

export type ReadTreasuriesVariables = ClochetteContext['fetcherOptions'];

/**
 * Returns a list of all treasuries.
 *
 * Requires a user with the 'treasurer' scope to be authenticated.
 */
export const fetchReadTreasuries = (variables: ReadTreasuriesVariables, signal?: AbortSignal) => clochetteFetch<ReadTreasuriesResponse, ReadTreasuriesError, undefined, {}, {}, {}>({ url: '/api/v1/treasury/', method: 'get', ...variables, signal });

/**
 * Returns a list of all treasuries.
 *
 * Requires a user with the 'treasurer' scope to be authenticated.
 */
export const useReadTreasuries = <TData = ReadTreasuriesResponse>(variables: ReadTreasuriesVariables, options?: Omit<reactQuery.UseQueryOptions<ReadTreasuriesResponse, ReadTreasuriesError, TData>, 'queryKey' | 'queryFn'>) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useClochetteContext(options);
  return reactQuery.useQuery<ReadTreasuriesResponse, ReadTreasuriesError, TData>({
    queryKey: queryKeyFn({ path: '/api/v1/treasury/', operationId: 'readTreasuries', variables }),
    queryFn: ({ signal }) => fetchReadTreasuries({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions
  });
};

export type ReadLastTreasuryError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.HTTPError;
    }
  | {
      status: 401;
      payload: Schemas.HTTPError;
    }
  | {
      status: 404;
      payload: Schemas.HTTPError;
    }
>;

export type ReadLastTreasuryVariables = ClochetteContext['fetcherOptions'];

/**
 * Returns the last treasury.
 *
 * Requires a user with the 'treasurer' scope to be authenticated.
 */
export const fetchReadLastTreasury = (variables: ReadLastTreasuryVariables, signal?: AbortSignal) => clochetteFetch<Schemas.Treasury, ReadLastTreasuryError, undefined, {}, {}, {}>({ url: '/api/v1/treasury/last', method: 'get', ...variables, signal });

/**
 * Returns the last treasury.
 *
 * Requires a user with the 'treasurer' scope to be authenticated.
 */
export const useReadLastTreasury = <TData = Schemas.Treasury>(variables: ReadLastTreasuryVariables, options?: Omit<reactQuery.UseQueryOptions<Schemas.Treasury, ReadLastTreasuryError, TData>, 'queryKey' | 'queryFn'>) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useClochetteContext(options);
  return reactQuery.useQuery<Schemas.Treasury, ReadLastTreasuryError, TData>({
    queryKey: queryKeyFn({ path: '/api/v1/treasury/last', operationId: 'readLastTreasury', variables }),
    queryFn: ({ signal }) => fetchReadLastTreasury({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions
  });
};

export type UpdateTreasuryPathParams = {
  treasuryId: number;
};

export type UpdateTreasuryError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.HTTPError;
    }
  | {
      status: 401;
      payload: Schemas.HTTPError;
    }
  | {
      status: 404;
      payload: Schemas.HTTPError;
    }
  | {
      status: 422;
      payload: Schemas.HTTPValidationError;
    }
>;

export type UpdateTreasuryVariables = {
  body?: Schemas.TreasuryUpdate;
  pathParams: UpdateTreasuryPathParams;
} & ClochetteContext['fetcherOptions'];

/**
 * Updates a treasury with the given ID.
 *
 * Requires a user with the 'treasurer' scope to be authenticated.
 */
export const fetchUpdateTreasury = (variables: UpdateTreasuryVariables, signal?: AbortSignal) =>
  clochetteFetch<Schemas.Treasury, UpdateTreasuryError, Schemas.TreasuryUpdate, {}, {}, UpdateTreasuryPathParams>({ url: '/api/v1/treasury/{treasuryId}', method: 'put', ...variables, signal });

/**
 * Updates a treasury with the given ID.
 *
 * Requires a user with the 'treasurer' scope to be authenticated.
 */
export const useUpdateTreasury = (options?: Omit<reactQuery.UseMutationOptions<Schemas.Treasury, UpdateTreasuryError, UpdateTreasuryVariables>, 'mutationFn'>) => {
  const { fetcherOptions } = useClochetteContext();
  return reactQuery.useMutation<Schemas.Treasury, UpdateTreasuryError, UpdateTreasuryVariables>({
    mutationFn: (variables: UpdateTreasuryVariables) => fetchUpdateTreasury({ ...fetcherOptions, ...variables }),
    ...options
  });
};

export type ReadBarrelsQueryParams = {
  /**
   * @default false
   */
  all?: boolean;
  is_mounted?: boolean | null;
  drink_item_id?: number | null;
};

export type ReadBarrelsError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.HTTPError;
    }
  | {
      status: 401;
      payload: Schemas.HTTPError;
    }
  | {
      status: 404;
      payload: Schemas.HTTPError;
    }
  | {
      status: 422;
      payload: Schemas.HTTPValidationError;
    }
>;

export type ReadBarrelsResponse = Schemas.Barrel[];

export type ReadBarrelsVariables = {
  queryParams?: ReadBarrelsQueryParams;
} & ClochetteContext['fetcherOptions'];

/**
 * Read barrels from the database.
 *
 * Query parameters:
 *     - `all`: A boolean indicating whether to return all consumables or only non-empty ones.
 *     - `is_mounted`: If specified, if True, return only mounted barrels, else if False,
 *             return only unmounted barrels.
 *     - `drink_item_id`: If specified, return only barrels containing the specified drink item.
 */
export const fetchReadBarrels = (variables: ReadBarrelsVariables, signal?: AbortSignal) => clochetteFetch<ReadBarrelsResponse, ReadBarrelsError, undefined, {}, ReadBarrelsQueryParams, {}>({ url: '/api/v2/barrel/', method: 'get', ...variables, signal });

/**
 * Read barrels from the database.
 *
 * Query parameters:
 *     - `all`: A boolean indicating whether to return all consumables or only non-empty ones.
 *     - `is_mounted`: If specified, if True, return only mounted barrels, else if False,
 *             return only unmounted barrels.
 *     - `drink_item_id`: If specified, return only barrels containing the specified drink item.
 */
export const useReadBarrels = <TData = ReadBarrelsResponse>(variables: ReadBarrelsVariables, options?: Omit<reactQuery.UseQueryOptions<ReadBarrelsResponse, ReadBarrelsError, TData>, 'queryKey' | 'queryFn'>) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useClochetteContext(options);
  return reactQuery.useQuery<ReadBarrelsResponse, ReadBarrelsError, TData>({
    queryKey: queryKeyFn({ path: '/api/v2/barrel/', operationId: 'readBarrels', variables }),
    queryFn: ({ signal }) => fetchReadBarrels({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions
  });
};

export type CreateBarrelError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.HTTPError;
    }
  | {
      status: 401;
      payload: Schemas.HTTPError;
    }
  | {
      status: 404;
      payload: Schemas.HTTPError;
    }
  | {
      status: 422;
      payload: Schemas.HTTPValidationError;
    }
>;

export type CreateBarrelVariables = {
  body: Schemas.BarrelCreate;
} & ClochetteContext['fetcherOptions'];

/**
 * Create a barrel in the database.
 */
export const fetchCreateBarrel = (variables: CreateBarrelVariables, signal?: AbortSignal) => clochetteFetch<Schemas.Barrel, CreateBarrelError, Schemas.BarrelCreate, {}, {}, {}>({ url: '/api/v2/barrel/', method: 'post', ...variables, signal });

/**
 * Create a barrel in the database.
 */
export const useCreateBarrel = (options?: Omit<reactQuery.UseMutationOptions<Schemas.Barrel, CreateBarrelError, CreateBarrelVariables>, 'mutationFn'>) => {
  const { fetcherOptions } = useClochetteContext();
  return reactQuery.useMutation<Schemas.Barrel, CreateBarrelError, CreateBarrelVariables>({
    mutationFn: (variables: CreateBarrelVariables) => fetchCreateBarrel({ ...fetcherOptions, ...variables }),
    ...options
  });
};

export type ReadDistinctBarrelsQueryParams = {
  is_mounted?: boolean | null;
};

export type ReadDistinctBarrelsError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.HTTPError;
    }
  | {
      status: 401;
      payload: Schemas.HTTPError;
    }
  | {
      status: 404;
      payload: Schemas.HTTPError;
    }
  | {
      status: 422;
      payload: Schemas.HTTPValidationError;
    }
>;

export type ReadDistinctBarrelsResponse = Schemas.BarrelDistinct[];

export type ReadDistinctBarrelsVariables = {
  queryParams?: ReadDistinctBarrelsQueryParams;
} & ClochetteContext['fetcherOptions'];

/**
 * Read distinct barrels from the database.
 *
 * Query parameters:
 *     - `is_mounted`: If specified, if True, return only mounted barrels, else if False,
 *             return only unmounted barrels.
 */
export const fetchReadDistinctBarrels = (variables: ReadDistinctBarrelsVariables, signal?: AbortSignal) =>
  clochetteFetch<ReadDistinctBarrelsResponse, ReadDistinctBarrelsError, undefined, {}, ReadDistinctBarrelsQueryParams, {}>({ url: '/api/v2/barrel/distincts/', method: 'get', ...variables, signal });

/**
 * Read distinct barrels from the database.
 *
 * Query parameters:
 *     - `is_mounted`: If specified, if True, return only mounted barrels, else if False,
 *             return only unmounted barrels.
 */
export const useReadDistinctBarrels = <TData = ReadDistinctBarrelsResponse>(variables: ReadDistinctBarrelsVariables, options?: Omit<reactQuery.UseQueryOptions<ReadDistinctBarrelsResponse, ReadDistinctBarrelsError, TData>, 'queryKey' | 'queryFn'>) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useClochetteContext(options);
  return reactQuery.useQuery<ReadDistinctBarrelsResponse, ReadDistinctBarrelsError, TData>({
    queryKey: queryKeyFn({ path: '/api/v2/barrel/distincts/', operationId: 'readDistinctBarrels', variables }),
    queryFn: ({ signal }) => fetchReadDistinctBarrels({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions
  });
};

export type UpdateBarrelPathParams = {
  barrelId: number;
};

export type UpdateBarrelError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.HTTPError;
    }
  | {
      status: 401;
      payload: Schemas.HTTPError;
    }
  | {
      status: 404;
      payload: Schemas.HTTPError;
    }
  | {
      status: 422;
      payload: Schemas.HTTPValidationError;
    }
>;

export type UpdateBarrelVariables = {
  body?: Schemas.BarrelUpdateModify;
  pathParams: UpdateBarrelPathParams;
} & ClochetteContext['fetcherOptions'];

/**
 * Update a barrel in the database.
 */
export const fetchUpdateBarrel = (variables: UpdateBarrelVariables, signal?: AbortSignal) =>
  clochetteFetch<Schemas.Barrel, UpdateBarrelError, Schemas.BarrelUpdateModify, {}, {}, UpdateBarrelPathParams>({ url: '/api/v2/barrel/{barrelId}', method: 'patch', ...variables, signal });

/**
 * Update a barrel in the database.
 */
export const useUpdateBarrel = (options?: Omit<reactQuery.UseMutationOptions<Schemas.Barrel, UpdateBarrelError, UpdateBarrelVariables>, 'mutationFn'>) => {
  const { fetcherOptions } = useClochetteContext();
  return reactQuery.useMutation<Schemas.Barrel, UpdateBarrelError, UpdateBarrelVariables>({
    mutationFn: (variables: UpdateBarrelVariables) => fetchUpdateBarrel({ ...fetcherOptions, ...variables }),
    ...options
  });
};

export type SaleBarrelPathParams = {
  barrelId: number;
};

export type SaleBarrelError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.HTTPError;
    }
  | {
      status: 401;
      payload: Schemas.HTTPError;
    }
  | {
      status: 404;
      payload: Schemas.HTTPError;
    }
  | {
      status: 422;
      payload: Schemas.HTTPValidationError;
    }
>;

export type SaleBarrelVariables = {
  body: Schemas.BarrelUpdateSale;
  pathParams: SaleBarrelPathParams;
} & ClochetteContext['fetcherOptions'];

/**
 * Update a barrel in the database.
 */
export const fetchSaleBarrel = (variables: SaleBarrelVariables, signal?: AbortSignal) =>
  clochetteFetch<Schemas.Barrel, SaleBarrelError, Schemas.BarrelUpdateSale, {}, {}, SaleBarrelPathParams>({ url: '/api/v2/barrel/{barrelId}/sale', method: 'patch', ...variables, signal });

/**
 * Update a barrel in the database.
 */
export const useSaleBarrel = (options?: Omit<reactQuery.UseMutationOptions<Schemas.Barrel, SaleBarrelError, SaleBarrelVariables>, 'mutationFn'>) => {
  const { fetcherOptions } = useClochetteContext();
  return reactQuery.useMutation<Schemas.Barrel, SaleBarrelError, SaleBarrelVariables>({
    mutationFn: (variables: SaleBarrelVariables) => fetchSaleBarrel({ ...fetcherOptions, ...variables }),
    ...options
  });
};

export type ReadConsumablesQueryParams = {
  /**
   * @default false
   */
  all?: boolean;
  consumable_item_id?: number | null;
};

export type ReadConsumablesError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.HTTPError;
    }
  | {
      status: 401;
      payload: Schemas.HTTPError;
    }
  | {
      status: 404;
      payload: Schemas.HTTPError;
    }
  | {
      status: 422;
      payload: Schemas.HTTPValidationError;
    }
>;

export type ReadConsumablesResponse = Schemas.Consumable[];

export type ReadConsumablesVariables = {
  queryParams?: ReadConsumablesQueryParams;
} & ClochetteContext['fetcherOptions'];

/**
 * Retrieve a list of consumables.
 *
 * Query parameters:
 *     - `all`: A boolean indicating whether to return all consumables or only non-empty ones.
 */
export const fetchReadConsumables = (variables: ReadConsumablesVariables, signal?: AbortSignal) =>
  clochetteFetch<ReadConsumablesResponse, ReadConsumablesError, undefined, {}, ReadConsumablesQueryParams, {}>({ url: '/api/v2/consumable/', method: 'get', ...variables, signal });

/**
 * Retrieve a list of consumables.
 *
 * Query parameters:
 *     - `all`: A boolean indicating whether to return all consumables or only non-empty ones.
 */
export const useReadConsumables = <TData = ReadConsumablesResponse>(variables: ReadConsumablesVariables, options?: Omit<reactQuery.UseQueryOptions<ReadConsumablesResponse, ReadConsumablesError, TData>, 'queryKey' | 'queryFn'>) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useClochetteContext(options);
  return reactQuery.useQuery<ReadConsumablesResponse, ReadConsumablesError, TData>({
    queryKey: queryKeyFn({ path: '/api/v2/consumable/', operationId: 'readConsumables', variables }),
    queryFn: ({ signal }) => fetchReadConsumables({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions
  });
};

export type CreateConsumableError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.HTTPError;
    }
  | {
      status: 401;
      payload: Schemas.HTTPError;
    }
  | {
      status: 404;
      payload: Schemas.HTTPError;
    }
  | {
      status: 422;
      payload: Schemas.HTTPValidationError;
    }
>;

export type CreateConsumableVariables = {
  body: Schemas.ConsumableCreate;
} & ClochetteContext['fetcherOptions'];

/**
 * Create a consumable.
 */
export const fetchCreateConsumable = (variables: CreateConsumableVariables, signal?: AbortSignal) =>
  clochetteFetch<Schemas.Consumable, CreateConsumableError, Schemas.ConsumableCreate, {}, {}, {}>({ url: '/api/v2/consumable/', method: 'post', ...variables, signal });

/**
 * Create a consumable.
 */
export const useCreateConsumable = (options?: Omit<reactQuery.UseMutationOptions<Schemas.Consumable, CreateConsumableError, CreateConsumableVariables>, 'mutationFn'>) => {
  const { fetcherOptions } = useClochetteContext();
  return reactQuery.useMutation<Schemas.Consumable, CreateConsumableError, CreateConsumableVariables>({
    mutationFn: (variables: CreateConsumableVariables) => fetchCreateConsumable({ ...fetcherOptions, ...variables }),
    ...options
  });
};

export type ReadConsumablePathParams = {
  consumableId: number;
};

export type ReadConsumableError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.HTTPError;
    }
  | {
      status: 401;
      payload: Schemas.HTTPError;
    }
  | {
      status: 404;
      payload: Schemas.HTTPError;
    }
  | {
      status: 422;
      payload: Schemas.HTTPValidationError;
    }
>;

export type ReadConsumableVariables = {
  pathParams: ReadConsumablePathParams;
} & ClochetteContext['fetcherOptions'];

/**
 * Retrieve a consumable.
 */
export const fetchReadConsumable = (variables: ReadConsumableVariables, signal?: AbortSignal) =>
  clochetteFetch<Schemas.Consumable, ReadConsumableError, undefined, {}, {}, ReadConsumablePathParams>({ url: '/api/v2/consumable/{consumableId}', method: 'get', ...variables, signal });

/**
 * Retrieve a consumable.
 */
export const useReadConsumable = <TData = Schemas.Consumable>(variables: ReadConsumableVariables, options?: Omit<reactQuery.UseQueryOptions<Schemas.Consumable, ReadConsumableError, TData>, 'queryKey' | 'queryFn'>) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useClochetteContext(options);
  return reactQuery.useQuery<Schemas.Consumable, ReadConsumableError, TData>({
    queryKey: queryKeyFn({ path: '/api/v2/consumable/{consumable_id}', operationId: 'readConsumable', variables }),
    queryFn: ({ signal }) => fetchReadConsumable({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions
  });
};

export type UpdateConsumablePathParams = {
  consumableId: number;
};

export type UpdateConsumableError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.HTTPError;
    }
  | {
      status: 401;
      payload: Schemas.HTTPError;
    }
  | {
      status: 404;
      payload: Schemas.HTTPError;
    }
  | {
      status: 422;
      payload: Schemas.HTTPValidationError;
    }
>;

export type UpdateConsumableVariables = {
  body?: Schemas.ConsumableUpdateModify;
  pathParams: UpdateConsumablePathParams;
} & ClochetteContext['fetcherOptions'];

/**
 * Update a consumable.
 */
export const fetchUpdateConsumable = (variables: UpdateConsumableVariables, signal?: AbortSignal) =>
  clochetteFetch<Schemas.Consumable, UpdateConsumableError, Schemas.ConsumableUpdateModify, {}, {}, UpdateConsumablePathParams>({ url: '/api/v2/consumable/{consumableId}', method: 'patch', ...variables, signal });

/**
 * Update a consumable.
 */
export const useUpdateConsumable = (options?: Omit<reactQuery.UseMutationOptions<Schemas.Consumable, UpdateConsumableError, UpdateConsumableVariables>, 'mutationFn'>) => {
  const { fetcherOptions } = useClochetteContext();
  return reactQuery.useMutation<Schemas.Consumable, UpdateConsumableError, UpdateConsumableVariables>({
    mutationFn: (variables: UpdateConsumableVariables) => fetchUpdateConsumable({ ...fetcherOptions, ...variables }),
    ...options
  });
};

export type ReadDistinctConsumablesError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.HTTPError;
    }
  | {
      status: 401;
      payload: Schemas.HTTPError;
    }
  | {
      status: 404;
      payload: Schemas.HTTPError;
    }
>;

export type ReadDistinctConsumablesResponse = Schemas.ConsumableDistinct[];

export type ReadDistinctConsumablesVariables = ClochetteContext['fetcherOptions'];

/**
 * Retrieve a list of distinct consumables.
 */
export const fetchReadDistinctConsumables = (variables: ReadDistinctConsumablesVariables, signal?: AbortSignal) =>
  clochetteFetch<ReadDistinctConsumablesResponse, ReadDistinctConsumablesError, undefined, {}, {}, {}>({ url: '/api/v2/consumable/distincts/', method: 'get', ...variables, signal });

/**
 * Retrieve a list of distinct consumables.
 */
export const useReadDistinctConsumables = <TData = ReadDistinctConsumablesResponse>(
  variables: ReadDistinctConsumablesVariables,
  options?: Omit<reactQuery.UseQueryOptions<ReadDistinctConsumablesResponse, ReadDistinctConsumablesError, TData>, 'queryKey' | 'queryFn'>
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useClochetteContext(options);
  return reactQuery.useQuery<ReadDistinctConsumablesResponse, ReadDistinctConsumablesError, TData>({
    queryKey: queryKeyFn({ path: '/api/v2/consumable/distincts/', operationId: 'readDistinctConsumables', variables }),
    queryFn: ({ signal }) => fetchReadDistinctConsumables({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions
  });
};

export type SaleConsumablePathParams = {
  consumableId: number;
};

export type SaleConsumableError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.HTTPError;
    }
  | {
      status: 401;
      payload: Schemas.HTTPError;
    }
  | {
      status: 404;
      payload: Schemas.HTTPError;
    }
  | {
      status: 422;
      payload: Schemas.HTTPValidationError;
    }
>;

export type SaleConsumableVariables = {
  body?: Schemas.ConsumableUpdateSale;
  pathParams: SaleConsumablePathParams;
} & ClochetteContext['fetcherOptions'];

/**
 * Sale a consumable.
 */
export const fetchSaleConsumable = (variables: SaleConsumableVariables, signal?: AbortSignal) =>
  clochetteFetch<Schemas.Consumable, SaleConsumableError, Schemas.ConsumableUpdateSale, {}, {}, SaleConsumablePathParams>({ url: '/api/v2/consumable/{consumableId}/sale', method: 'patch', ...variables, signal });

/**
 * Sale a consumable.
 */
export const useSaleConsumable = (options?: Omit<reactQuery.UseMutationOptions<Schemas.Consumable, SaleConsumableError, SaleConsumableVariables>, 'mutationFn'>) => {
  const { fetcherOptions } = useClochetteContext();
  return reactQuery.useMutation<Schemas.Consumable, SaleConsumableError, SaleConsumableVariables>({
    mutationFn: (variables: SaleConsumableVariables) => fetchSaleConsumable({ ...fetcherOptions, ...variables }),
    ...options
  });
};

export type ReadGlassesQueryParams = {
  barrel_id?: number | null;
  transaction_sell_price?: number | null;
};

export type ReadGlassesError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.HTTPError;
    }
  | {
      status: 401;
      payload: Schemas.HTTPError;
    }
  | {
      status: 404;
      payload: Schemas.HTTPError;
    }
  | {
      status: 422;
      payload: Schemas.HTTPValidationError;
    }
>;

export type ReadGlassesResponse = Schemas.Glass[];

export type ReadGlassesVariables = {
  queryParams?: ReadGlassesQueryParams;
} & ClochetteContext['fetcherOptions'];

/**
 * Retrieve a list of glasses that match the given query parameters.
 */
export const fetchReadGlasses = (variables: ReadGlassesVariables, signal?: AbortSignal) => clochetteFetch<ReadGlassesResponse, ReadGlassesError, undefined, {}, ReadGlassesQueryParams, {}>({ url: '/api/v2/glass/', method: 'get', ...variables, signal });

/**
 * Retrieve a list of glasses that match the given query parameters.
 */
export const useReadGlasses = <TData = ReadGlassesResponse>(variables: ReadGlassesVariables, options?: Omit<reactQuery.UseQueryOptions<ReadGlassesResponse, ReadGlassesError, TData>, 'queryKey' | 'queryFn'>) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useClochetteContext(options);
  return reactQuery.useQuery<ReadGlassesResponse, ReadGlassesError, TData>({
    queryKey: queryKeyFn({ path: '/api/v2/glass/', operationId: 'readGlasses', variables }),
    queryFn: ({ signal }) => fetchReadGlasses({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions
  });
};

export type CreateGlassError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.HTTPError;
    }
  | {
      status: 401;
      payload: Schemas.HTTPError;
    }
  | {
      status: 404;
      payload: Schemas.HTTPError;
    }
  | {
      status: 422;
      payload: Schemas.HTTPValidationError;
    }
>;

export type CreateGlassVariables = {
  body: Schemas.GlassCreate;
} & ClochetteContext['fetcherOptions'];

/**
 * Create a new glass in the database.
 */
export const fetchCreateGlass = (variables: CreateGlassVariables, signal?: AbortSignal) => clochetteFetch<Schemas.Glass, CreateGlassError, Schemas.GlassCreate, {}, {}, {}>({ url: '/api/v2/glass/', method: 'post', ...variables, signal });

/**
 * Create a new glass in the database.
 */
export const useCreateGlass = (options?: Omit<reactQuery.UseMutationOptions<Schemas.Glass, CreateGlassError, CreateGlassVariables>, 'mutationFn'>) => {
  const { fetcherOptions } = useClochetteContext();
  return reactQuery.useMutation<Schemas.Glass, CreateGlassError, CreateGlassVariables>({
    mutationFn: (variables: CreateGlassVariables) => fetchCreateGlass({ ...fetcherOptions, ...variables }),
    ...options
  });
};

export type ReadGlassPathParams = {
  glassId: number;
};

export type ReadGlassError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.HTTPError;
    }
  | {
      status: 401;
      payload: Schemas.HTTPError;
    }
  | {
      status: 404;
      payload: Schemas.HTTPError;
    }
  | {
      status: 422;
      payload: Schemas.HTTPValidationError;
    }
>;

export type ReadGlassVariables = {
  pathParams: ReadGlassPathParams;
} & ClochetteContext['fetcherOptions'];

/**
 * Retrieve a glass.
 */
export const fetchReadGlass = (variables: ReadGlassVariables, signal?: AbortSignal) => clochetteFetch<Schemas.Glass, ReadGlassError, undefined, {}, {}, ReadGlassPathParams>({ url: '/api/v2/glass/{glassId}', method: 'get', ...variables, signal });

/**
 * Retrieve a glass.
 */
export const useReadGlass = <TData = Schemas.Glass>(variables: ReadGlassVariables, options?: Omit<reactQuery.UseQueryOptions<Schemas.Glass, ReadGlassError, TData>, 'queryKey' | 'queryFn'>) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useClochetteContext(options);
  return reactQuery.useQuery<Schemas.Glass, ReadGlassError, TData>({
    queryKey: queryKeyFn({ path: '/api/v2/glass/{glass_id}', operationId: 'readGlass', variables }),
    queryFn: ({ signal }) => fetchReadGlass({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions
  });
};

export type ReadNonInventoriedsError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.HTTPError;
    }
  | {
      status: 401;
      payload: Schemas.HTTPError;
    }
  | {
      status: 404;
      payload: Schemas.HTTPError;
    }
>;

export type ReadNonInventoriedsResponse = Schemas.NonInventoried[];

export type ReadNonInventoriedsVariables = ClochetteContext['fetcherOptions'];

/**
 * Retrieve a list of non inventorieds.
 */
export const fetchReadNonInventorieds = (variables: ReadNonInventoriedsVariables, signal?: AbortSignal) =>
  clochetteFetch<ReadNonInventoriedsResponse, ReadNonInventoriedsError, undefined, {}, {}, {}>({ url: '/api/v2/non_inventoried/', method: 'get', ...variables, signal });

/**
 * Retrieve a list of non inventorieds.
 */
export const useReadNonInventorieds = <TData = ReadNonInventoriedsResponse>(variables: ReadNonInventoriedsVariables, options?: Omit<reactQuery.UseQueryOptions<ReadNonInventoriedsResponse, ReadNonInventoriedsError, TData>, 'queryKey' | 'queryFn'>) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useClochetteContext(options);
  return reactQuery.useQuery<ReadNonInventoriedsResponse, ReadNonInventoriedsError, TData>({
    queryKey: queryKeyFn({ path: '/api/v2/non_inventoried/', operationId: 'readNonInventorieds', variables }),
    queryFn: ({ signal }) => fetchReadNonInventorieds({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions
  });
};

export type CreateNonInventoriedError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.HTTPError;
    }
  | {
      status: 401;
      payload: Schemas.HTTPError;
    }
  | {
      status: 404;
      payload: Schemas.HTTPError;
    }
  | {
      status: 422;
      payload: Schemas.HTTPValidationError;
    }
>;

export type CreateNonInventoriedVariables = {
  body: Schemas.NonInventoriedCreate;
} & ClochetteContext['fetcherOptions'];

/**
 * Create a new non inventoried.
 */
export const fetchCreateNonInventoried = (variables: CreateNonInventoriedVariables, signal?: AbortSignal) =>
  clochetteFetch<Schemas.NonInventoried, CreateNonInventoriedError, Schemas.NonInventoriedCreate, {}, {}, {}>({ url: '/api/v2/non_inventoried/', method: 'post', ...variables, signal });

/**
 * Create a new non inventoried.
 */
export const useCreateNonInventoried = (options?: Omit<reactQuery.UseMutationOptions<Schemas.NonInventoried, CreateNonInventoriedError, CreateNonInventoriedVariables>, 'mutationFn'>) => {
  const { fetcherOptions } = useClochetteContext();
  return reactQuery.useMutation<Schemas.NonInventoried, CreateNonInventoriedError, CreateNonInventoriedVariables>({
    mutationFn: (variables: CreateNonInventoriedVariables) => fetchCreateNonInventoried({ ...fetcherOptions, ...variables }),
    ...options
  });
};

export type ReadNonInventoriedPathParams = {
  nonInventoriedId: number;
};

export type ReadNonInventoriedError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.HTTPError;
    }
  | {
      status: 401;
      payload: Schemas.HTTPError;
    }
  | {
      status: 404;
      payload: Schemas.HTTPError;
    }
  | {
      status: 422;
      payload: Schemas.HTTPValidationError;
    }
>;

export type ReadNonInventoriedVariables = {
  pathParams: ReadNonInventoriedPathParams;
} & ClochetteContext['fetcherOptions'];

/**
 * Retrieve a non inventoried.
 */
export const fetchReadNonInventoried = (variables: ReadNonInventoriedVariables, signal?: AbortSignal) =>
  clochetteFetch<Schemas.NonInventoried, ReadNonInventoriedError, undefined, {}, {}, ReadNonInventoriedPathParams>({ url: '/api/v2/non_inventoried/{nonInventoriedId}', method: 'get', ...variables, signal });

/**
 * Retrieve a non inventoried.
 */
export const useReadNonInventoried = <TData = Schemas.NonInventoried>(variables: ReadNonInventoriedVariables, options?: Omit<reactQuery.UseQueryOptions<Schemas.NonInventoried, ReadNonInventoriedError, TData>, 'queryKey' | 'queryFn'>) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useClochetteContext(options);
  return reactQuery.useQuery<Schemas.NonInventoried, ReadNonInventoriedError, TData>({
    queryKey: queryKeyFn({ path: '/api/v2/non_inventoried/{non_inventoried_id}', operationId: 'readNonInventoried', variables }),
    queryFn: ({ signal }) => fetchReadNonInventoried({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions
  });
};

export type ReadNonInventoriedItemsQueryParams = {
  trade?: Schemas.TradeType | null;
  name?: string | null;
};

export type ReadNonInventoriedItemsError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.HTTPError;
    }
  | {
      status: 401;
      payload: Schemas.HTTPError;
    }
  | {
      status: 404;
      payload: Schemas.HTTPError;
    }
  | {
      status: 422;
      payload: Schemas.HTTPValidationError;
    }
>;

export type ReadNonInventoriedItemsResponse = Schemas.NonInventoriedItem[];

export type ReadNonInventoriedItemsVariables = {
  queryParams?: ReadNonInventoriedItemsQueryParams;
} & ClochetteContext['fetcherOptions'];

/**
 * Retrieve a list of non inventoried items.
 *
 * Query parameters:
 *     - `trade`: The trade type.
 *     - `name`: The non inventoried item name.
 */
export const fetchReadNonInventoriedItems = (variables: ReadNonInventoriedItemsVariables, signal?: AbortSignal) =>
  clochetteFetch<ReadNonInventoriedItemsResponse, ReadNonInventoriedItemsError, undefined, {}, ReadNonInventoriedItemsQueryParams, {}>({ url: '/api/v2/non_inventoried_item/', method: 'get', ...variables, signal });

/**
 * Retrieve a list of non inventoried items.
 *
 * Query parameters:
 *     - `trade`: The trade type.
 *     - `name`: The non inventoried item name.
 */
export const useReadNonInventoriedItems = <TData = ReadNonInventoriedItemsResponse>(
  variables: ReadNonInventoriedItemsVariables,
  options?: Omit<reactQuery.UseQueryOptions<ReadNonInventoriedItemsResponse, ReadNonInventoriedItemsError, TData>, 'queryKey' | 'queryFn'>
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useClochetteContext(options);
  return reactQuery.useQuery<ReadNonInventoriedItemsResponse, ReadNonInventoriedItemsError, TData>({
    queryKey: queryKeyFn({ path: '/api/v2/non_inventoried_item/', operationId: 'readNonInventoriedItems', variables }),
    queryFn: ({ signal }) => fetchReadNonInventoriedItems({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions
  });
};

export type CreateNonInventoriedItemError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.HTTPError;
    }
  | {
      status: 401;
      payload: Schemas.HTTPError;
    }
  | {
      status: 404;
      payload: Schemas.HTTPError;
    }
  | {
      status: 422;
      payload: Schemas.HTTPValidationError;
    }
>;

export type CreateNonInventoriedItemVariables = {
  body: Schemas.NonInventoriedItemCreate;
} & ClochetteContext['fetcherOptions'];

/**
 * Create a non inventoried item.
 */
export const fetchCreateNonInventoriedItem = (variables: CreateNonInventoriedItemVariables, signal?: AbortSignal) =>
  clochetteFetch<Schemas.NonInventoriedItem, CreateNonInventoriedItemError, Schemas.NonInventoriedItemCreate, {}, {}, {}>({ url: '/api/v2/non_inventoried_item/', method: 'post', ...variables, signal });

/**
 * Create a non inventoried item.
 */
export const useCreateNonInventoriedItem = (options?: Omit<reactQuery.UseMutationOptions<Schemas.NonInventoriedItem, CreateNonInventoriedItemError, CreateNonInventoriedItemVariables>, 'mutationFn'>) => {
  const { fetcherOptions } = useClochetteContext();
  return reactQuery.useMutation<Schemas.NonInventoriedItem, CreateNonInventoriedItemError, CreateNonInventoriedItemVariables>({
    mutationFn: (variables: CreateNonInventoriedItemVariables) => fetchCreateNonInventoriedItem({ ...fetcherOptions, ...variables }),
    ...options
  });
};

export type ReadNonInventoriedItemPathParams = {
  nonInventoriedItemId: number;
};

export type ReadNonInventoriedItemError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.HTTPError;
    }
  | {
      status: 401;
      payload: Schemas.HTTPError;
    }
  | {
      status: 404;
      payload: Schemas.HTTPError;
    }
  | {
      status: 422;
      payload: Schemas.HTTPValidationError;
    }
>;

export type ReadNonInventoriedItemVariables = {
  pathParams: ReadNonInventoriedItemPathParams;
} & ClochetteContext['fetcherOptions'];

/**
 * Retrieve a non inventoried item.
 */
export const fetchReadNonInventoriedItem = (variables: ReadNonInventoriedItemVariables, signal?: AbortSignal) =>
  clochetteFetch<Schemas.NonInventoriedItem, ReadNonInventoriedItemError, undefined, {}, {}, ReadNonInventoriedItemPathParams>({ url: '/api/v2/non_inventoried_item/{nonInventoriedItemId}', method: 'get', ...variables, signal });

/**
 * Retrieve a non inventoried item.
 */
export const useReadNonInventoriedItem = <TData = Schemas.NonInventoriedItem>(
  variables: ReadNonInventoriedItemVariables,
  options?: Omit<reactQuery.UseQueryOptions<Schemas.NonInventoriedItem, ReadNonInventoriedItemError, TData>, 'queryKey' | 'queryFn'>
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useClochetteContext(options);
  return reactQuery.useQuery<Schemas.NonInventoriedItem, ReadNonInventoriedItemError, TData>({
    queryKey: queryKeyFn({ path: '/api/v2/non_inventoried_item/{non_inventoried_item_id}', operationId: 'readNonInventoriedItem', variables }),
    queryFn: ({ signal }) => fetchReadNonInventoriedItem({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions
  });
};

export type UpdateNonInventoriedItemPathParams = {
  nonInventoriedItemId: number;
};

export type UpdateNonInventoriedItemError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.HTTPError;
    }
  | {
      status: 401;
      payload: Schemas.HTTPError;
    }
  | {
      status: 404;
      payload: Schemas.HTTPError;
    }
  | {
      status: 422;
      payload: Schemas.HTTPValidationError;
    }
>;

export type UpdateNonInventoriedItemVariables = {
  body?: Schemas.NonInventoriedItemUpdate;
  pathParams: UpdateNonInventoriedItemPathParams;
} & ClochetteContext['fetcherOptions'];

/**
 * Update a non inventoried item.
 */
export const fetchUpdateNonInventoriedItem = (variables: UpdateNonInventoriedItemVariables, signal?: AbortSignal) =>
  clochetteFetch<Schemas.NonInventoriedItem, UpdateNonInventoriedItemError, Schemas.NonInventoriedItemUpdate, {}, {}, UpdateNonInventoriedItemPathParams>({
    url: '/api/v2/non_inventoried_item/{nonInventoriedItemId}',
    method: 'patch',
    ...variables,
    signal
  });

/**
 * Update a non inventoried item.
 */
export const useUpdateNonInventoriedItem = (options?: Omit<reactQuery.UseMutationOptions<Schemas.NonInventoriedItem, UpdateNonInventoriedItemError, UpdateNonInventoriedItemVariables>, 'mutationFn'>) => {
  const { fetcherOptions } = useClochetteContext();
  return reactQuery.useMutation<Schemas.NonInventoriedItem, UpdateNonInventoriedItemError, UpdateNonInventoriedItemVariables>({
    mutationFn: (variables: UpdateNonInventoriedItemVariables) => fetchUpdateNonInventoriedItem({ ...fetcherOptions, ...variables }),
    ...options
  });
};

export type DeleteNonInventoriedItemPathParams = {
  nonInventoriedItemId: number;
};

export type DeleteNonInventoriedItemError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.HTTPError;
    }
  | {
      status: 401;
      payload: Schemas.HTTPError;
    }
  | {
      status: 404;
      payload: Schemas.HTTPError;
    }
  | {
      status: 422;
      payload: Schemas.HTTPValidationError;
    }
>;

export type DeleteNonInventoriedItemVariables = {
  pathParams: DeleteNonInventoriedItemPathParams;
} & ClochetteContext['fetcherOptions'];

/**
 * Delete a non inventoried item.
 */
export const fetchDeleteNonInventoriedItem = (variables: DeleteNonInventoriedItemVariables, signal?: AbortSignal) =>
  clochetteFetch<Schemas.NonInventoriedItem, DeleteNonInventoriedItemError, undefined, {}, {}, DeleteNonInventoriedItemPathParams>({ url: '/api/v2/non_inventoried_item/{nonInventoriedItemId}', method: 'delete', ...variables, signal });

/**
 * Delete a non inventoried item.
 */
export const useDeleteNonInventoriedItem = (options?: Omit<reactQuery.UseMutationOptions<Schemas.NonInventoriedItem, DeleteNonInventoriedItemError, DeleteNonInventoriedItemVariables>, 'mutationFn'>) => {
  const { fetcherOptions } = useClochetteContext();
  return reactQuery.useMutation<Schemas.NonInventoriedItem, DeleteNonInventoriedItemError, DeleteNonInventoriedItemVariables>({
    mutationFn: (variables: DeleteNonInventoriedItemVariables) => fetchDeleteNonInventoriedItem({ ...fetcherOptions, ...variables }),
    ...options
  });
};

export type CreateTransactionError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.HTTPError;
    }
  | {
      status: 401;
      payload: Schemas.HTTPError;
    }
  | {
      status: 404;
      payload: Schemas.HTTPError;
    }
  | {
      status: 422;
      payload: Schemas.HTTPValidationError;
    }
>;

export type CreateTransactionVariables = {
  body: Schemas.TransactionCommerceCreate;
} & ClochetteContext['fetcherOptions'];

/**
 * Create a new transaction in the database.
 */
export const fetchCreateTransaction = (variables: CreateTransactionVariables, signal?: AbortSignal) =>
  clochetteFetch<Schemas.Transaction, CreateTransactionError, Schemas.TransactionCommerceCreate, {}, {}, {}>({ url: '/api/v2/transaction/', method: 'post', ...variables, signal });

/**
 * Create a new transaction in the database.
 */
export const useCreateTransaction = (options?: Omit<reactQuery.UseMutationOptions<Schemas.Transaction, CreateTransactionError, CreateTransactionVariables>, 'mutationFn'>) => {
  const { fetcherOptions } = useClochetteContext();
  return reactQuery.useMutation<Schemas.Transaction, CreateTransactionError, CreateTransactionVariables>({
    mutationFn: (variables: CreateTransactionVariables) => fetchCreateTransaction({ ...fetcherOptions, ...variables }),
    ...options
  });
};

export type ReadTransactionsQueryParams = {
  datetime__gt?: string | null;
  datetime__lt?: string | null;
  amount__gt?: number | null;
  amount__lt?: number | null;
  payment_method?: Schemas.PaymentMethod | null;
  trade?: Schemas.TradeType | null;
  type?: Schemas.TransactionType | null;
  status?: Schemas.Status | null;
};

export type ReadTransactionsError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.HTTPError;
    }
  | {
      status: 401;
      payload: Schemas.HTTPError;
    }
  | {
      status: 404;
      payload: Schemas.HTTPError;
    }
  | {
      status: 422;
      payload: Schemas.HTTPValidationError;
    }
>;

export type ReadTransactionsResponse = Schemas.Transaction[];

export type ReadTransactionsVariables = {
  queryParams?: ReadTransactionsQueryParams;
} & ClochetteContext['fetcherOptions'];

/**
 * Retrieve transactions.
 */
export const fetchReadTransactions = (variables: ReadTransactionsVariables, signal?: AbortSignal) =>
  clochetteFetch<ReadTransactionsResponse, ReadTransactionsError, undefined, {}, ReadTransactionsQueryParams, {}>({ url: '/api/v2/transaction/', method: 'get', ...variables, signal });

/**
 * Retrieve transactions.
 */
export const useReadTransactions = <TData = ReadTransactionsResponse>(variables: ReadTransactionsVariables, options?: Omit<reactQuery.UseQueryOptions<ReadTransactionsResponse, ReadTransactionsError, TData>, 'queryKey' | 'queryFn'>) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useClochetteContext(options);
  return reactQuery.useQuery<ReadTransactionsResponse, ReadTransactionsError, TData>({
    queryKey: queryKeyFn({ path: '/api/v2/transaction/', operationId: 'readTransactions', variables }),
    queryFn: ({ signal }) => fetchReadTransactions({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions
  });
};

export type CreateTreasuryTransactionError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.HTTPError;
    }
  | {
      status: 401;
      payload: Schemas.HTTPError;
    }
  | {
      status: 404;
      payload: Schemas.HTTPError;
    }
  | {
      status: 422;
      payload: Schemas.HTTPValidationError;
    }
>;

export type CreateTreasuryTransactionVariables = {
  body: Schemas.TransactionTreasuryCreate;
} & ClochetteContext['fetcherOptions'];

/**
 * Create a new transaction in the database.
 *
 * This endpoint requires authentication with the "treasury" scope.
 */
export const fetchCreateTreasuryTransaction = (variables: CreateTreasuryTransactionVariables, signal?: AbortSignal) =>
  clochetteFetch<Schemas.Transaction, CreateTreasuryTransactionError, Schemas.TransactionTreasuryCreate, {}, {}, {}>({ url: '/api/v2/transaction/treasury/', method: 'post', ...variables, signal });

/**
 * Create a new transaction in the database.
 *
 * This endpoint requires authentication with the "treasury" scope.
 */
export const useCreateTreasuryTransaction = (options?: Omit<reactQuery.UseMutationOptions<Schemas.Transaction, CreateTreasuryTransactionError, CreateTreasuryTransactionVariables>, 'mutationFn'>) => {
  const { fetcherOptions } = useClochetteContext();
  return reactQuery.useMutation<Schemas.Transaction, CreateTreasuryTransactionError, CreateTreasuryTransactionVariables>({
    mutationFn: (variables: CreateTreasuryTransactionVariables) => fetchCreateTreasuryTransaction({ ...fetcherOptions, ...variables }),
    ...options
  });
};

export type ValidateTransactionPathParams = {
  transactionId: number;
};

export type ValidateTransactionError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.HTTPError;
    }
  | {
      status: 401;
      payload: Schemas.HTTPError;
    }
  | {
      status: 404;
      payload: Schemas.HTTPError;
    }
  | {
      status: 422;
      payload: Schemas.HTTPValidationError;
    }
>;

export type ValidateTransactionVariables = {
  pathParams: ValidateTransactionPathParams;
} & ClochetteContext['fetcherOptions'];

/**
 * Validate a transaction.
 */
export const fetchValidateTransaction = (variables: ValidateTransactionVariables, signal?: AbortSignal) =>
  clochetteFetch<Schemas.Transaction, ValidateTransactionError, undefined, {}, {}, ValidateTransactionPathParams>({ url: '/api/v2/transaction/{transactionId}/validate', method: 'patch', ...variables, signal });

/**
 * Validate a transaction.
 */
export const useValidateTransaction = (options?: Omit<reactQuery.UseMutationOptions<Schemas.Transaction, ValidateTransactionError, ValidateTransactionVariables>, 'mutationFn'>) => {
  const { fetcherOptions } = useClochetteContext();
  return reactQuery.useMutation<Schemas.Transaction, ValidateTransactionError, ValidateTransactionVariables>({
    mutationFn: (variables: ValidateTransactionVariables) => fetchValidateTransaction({ ...fetcherOptions, ...variables }),
    ...options
  });
};

export type DeleteTransactionPathParams = {
  transactionId: number;
};

export type DeleteTransactionError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.HTTPError;
    }
  | {
      status: 401;
      payload: Schemas.HTTPError;
    }
  | {
      status: 404;
      payload: Schemas.HTTPError;
    }
  | {
      status: 422;
      payload: Schemas.HTTPValidationError;
    }
>;

export type DeleteTransactionVariables = {
  pathParams: DeleteTransactionPathParams;
} & ClochetteContext['fetcherOptions'];

/**
 * Delete a transaction.
 *
 * This endpoint requires authentication with the "treasury" scope.
 */
export const fetchDeleteTransaction = (variables: DeleteTransactionVariables, signal?: AbortSignal) =>
  clochetteFetch<Schemas.TransactionDetail, DeleteTransactionError, undefined, {}, {}, DeleteTransactionPathParams>({ url: '/api/v2/transaction/{transactionId}', method: 'delete', ...variables, signal });

/**
 * Delete a transaction.
 *
 * This endpoint requires authentication with the "treasury" scope.
 */
export const useDeleteTransaction = (options?: Omit<reactQuery.UseMutationOptions<Schemas.TransactionDetail, DeleteTransactionError, DeleteTransactionVariables>, 'mutationFn'>) => {
  const { fetcherOptions } = useClochetteContext();
  return reactQuery.useMutation<Schemas.TransactionDetail, DeleteTransactionError, DeleteTransactionVariables>({
    mutationFn: (variables: DeleteTransactionVariables) => fetchDeleteTransaction({ ...fetcherOptions, ...variables }),
    ...options
  });
};

export type ReadTransactionPathParams = {
  transactionId: number;
};

export type ReadTransactionError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.HTTPError;
    }
  | {
      status: 401;
      payload: Schemas.HTTPError;
    }
  | {
      status: 404;
      payload: Schemas.HTTPError;
    }
  | {
      status: 422;
      payload: Schemas.HTTPValidationError;
    }
>;

export type ReadTransactionVariables = {
  pathParams: ReadTransactionPathParams;
} & ClochetteContext['fetcherOptions'];

/**
 * Retrieve a transaction.
 */
export const fetchReadTransaction = (variables: ReadTransactionVariables, signal?: AbortSignal) =>
  clochetteFetch<Schemas.TransactionDetail, ReadTransactionError, undefined, {}, {}, ReadTransactionPathParams>({ url: '/api/v2/transaction/{transactionId}', method: 'get', ...variables, signal });

/**
 * Retrieve a transaction.
 */
export const useReadTransaction = <TData = Schemas.TransactionDetail>(variables: ReadTransactionVariables, options?: Omit<reactQuery.UseQueryOptions<Schemas.TransactionDetail, ReadTransactionError, TData>, 'queryKey' | 'queryFn'>) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useClochetteContext(options);
  return reactQuery.useQuery<Schemas.TransactionDetail, ReadTransactionError, TData>({
    queryKey: queryKeyFn({ path: '/api/v2/transaction/{transaction_id}', operationId: 'readTransaction', variables }),
    queryFn: ({ signal }) => fetchReadTransaction({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions
  });
};

export type QueryOperation =
  | {
      path: '/api/v1/';
      operationId: 'root';
      variables: RootVariables;
    }
  | {
      path: '/api/v1/health';
      operationId: 'health';
      variables: HealthVariables;
    }
  | {
      path: '/api/v1/error';
      operationId: 'error';
      variables: ErrorVariables;
    }
  | {
      path: '/api/v1/version';
      operationId: 'version';
      variables: VersionVariables;
    }
  | {
      path: '/api/v1/account/';
      operationId: 'readAccounts';
      variables: ReadAccountsVariables;
    }
  | {
      path: '/api/v1/account/{account_id}';
      operationId: 'readAccount';
      variables: ReadAccountVariables;
    }
  | {
      path: '/api/v1/auth/me/';
      operationId: 'readAccountMe';
      variables: ReadAccountMeVariables;
    }
  | {
      path: '/api/v1/barrel/';
      operationId: 'v1ReadBarrels';
      variables: V1ReadBarrelsVariables;
    }
  | {
      path: '/api/v1/barrel/distincts/';
      operationId: 'v1ReadDistinctBarrels';
      variables: V1ReadDistinctBarrelsVariables;
    }
  | {
      path: '/api/v1/consumable/';
      operationId: 'v1ReadConsumables';
      variables: V1ReadConsumablesVariables;
    }
  | {
      path: '/api/v1/consumable/distincts/';
      operationId: 'v1ReadConsumablesDistincts';
      variables: V1ReadConsumablesDistinctsVariables;
    }
  | {
      path: '/api/v1/consumable_item/';
      operationId: 'readConsumableItems';
      variables: ReadConsumableItemsVariables;
    }
  | {
      path: '/api/v1/consumable_item/{consumable_item_id}';
      operationId: 'readConsumableItem';
      variables: ReadConsumableItemVariables;
    }
  | {
      path: '/api/v1/drink/{drink_id}';
      operationId: 'readDrink';
      variables: ReadDrinkVariables;
    }
  | {
      path: '/api/v1/drink/';
      operationId: 'readDrinks';
      variables: ReadDrinksVariables;
    }
  | {
      path: '/api/v1/glass/';
      operationId: 'v1ReadGlasses';
      variables: V1ReadGlassesVariables;
    }
  | {
      path: '/api/v1/out_of_stock/';
      operationId: 'readOutOfStocks';
      variables: ReadOutOfStocksVariables;
    }
  | {
      path: '/api/v1/out_of_stock_item/buy/';
      operationId: 'readOutOfStockItemsBuy';
      variables: ReadOutOfStockItemsBuyVariables;
    }
  | {
      path: '/api/v1/out_of_stock_item/sell/';
      operationId: 'readOutOfStockItemsSell';
      variables: ReadOutOfStockItemsSellVariables;
    }
  | {
      path: '/api/v1/out_of_stock_item/{out_of_stock_item_id}';
      operationId: 'readOutOfStockItem';
      variables: ReadOutOfStockItemVariables;
    }
  | {
      path: '/api/v1/transaction/';
      operationId: 'v1ReadTransactions';
      variables: V1ReadTransactionsVariables;
    }
  | {
      path: '/api/v1/transaction/{transaction_id}';
      operationId: 'v1ReadTransaction';
      variables: V1ReadTransactionVariables;
    }
  | {
      path: '/api/v1/treasury/';
      operationId: 'readTreasuries';
      variables: ReadTreasuriesVariables;
    }
  | {
      path: '/api/v1/treasury/last';
      operationId: 'readLastTreasury';
      variables: ReadLastTreasuryVariables;
    }
  | {
      path: '/api/v2/barrel/';
      operationId: 'readBarrels';
      variables: ReadBarrelsVariables;
    }
  | {
      path: '/api/v2/barrel/distincts/';
      operationId: 'readDistinctBarrels';
      variables: ReadDistinctBarrelsVariables;
    }
  | {
      path: '/api/v2/consumable/';
      operationId: 'readConsumables';
      variables: ReadConsumablesVariables;
    }
  | {
      path: '/api/v2/consumable/{consumable_id}';
      operationId: 'readConsumable';
      variables: ReadConsumableVariables;
    }
  | {
      path: '/api/v2/consumable/distincts/';
      operationId: 'readDistinctConsumables';
      variables: ReadDistinctConsumablesVariables;
    }
  | {
      path: '/api/v2/glass/';
      operationId: 'readGlasses';
      variables: ReadGlassesVariables;
    }
  | {
      path: '/api/v2/glass/{glass_id}';
      operationId: 'readGlass';
      variables: ReadGlassVariables;
    }
  | {
      path: '/api/v2/non_inventoried/';
      operationId: 'readNonInventorieds';
      variables: ReadNonInventoriedsVariables;
    }
  | {
      path: '/api/v2/non_inventoried/{non_inventoried_id}';
      operationId: 'readNonInventoried';
      variables: ReadNonInventoriedVariables;
    }
  | {
      path: '/api/v2/non_inventoried_item/';
      operationId: 'readNonInventoriedItems';
      variables: ReadNonInventoriedItemsVariables;
    }
  | {
      path: '/api/v2/non_inventoried_item/{non_inventoried_item_id}';
      operationId: 'readNonInventoriedItem';
      variables: ReadNonInventoriedItemVariables;
    }
  | {
      path: '/api/v2/transaction/';
      operationId: 'readTransactions';
      variables: ReadTransactionsVariables;
    }
  | {
      path: '/api/v2/transaction/{transaction_id}';
      operationId: 'readTransaction';
      variables: ReadTransactionVariables;
    };
